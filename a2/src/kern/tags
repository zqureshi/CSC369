!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARG_MAX	include/kern/limits.h	21;"	d
AT	arch/mips/include/asmdefs.h	11;"	d
BASE_VERSION	include/version.h	8;"	d
BITS_PER_WORD	include/bitmap.h	27;"	d
BLOCKS_PER_THREAD	test/buffertest1.c	15;"	d	file:
BOOTUP_PID	include/pid.h	10;"	d
BUFSIZE	include/cache.h	7;"	d
CCA_CODE	arch/mips/include/specialreg.h	21;"	d
CCA_CODESHIFT	arch/mips/include/specialreg.h	26;"	d
CCA_COPN	arch/mips/include/specialreg.h	23;"	d
CCA_IRQS	arch/mips/include/specialreg.h	22;"	d
CCA_JD	arch/mips/include/specialreg.h	24;"	d
CCA_UTLB	arch/mips/include/specialreg.h	20;"	d
CFGREG_DID	dev/lamebus/lamebus.c	12;"	d	file:
CFGREG_DRL	dev/lamebus/lamebus.c	13;"	d	file:
CFGREG_VID	dev/lamebus/lamebus.c	11;"	d	file:
CHAR_BIT	arch/mips/include/types.h	51;"	d
CIN_INDEX	arch/mips/include/specialreg.h	32;"	d
CIN_INDEXSHIFT	arch/mips/include/specialreg.h	34;"	d
CIN_P	arch/mips/include/specialreg.h	31;"	d
COMPUTE_ITERS	test/tt3.c	25;"	d	file:
CST_BEV	arch/mips/include/specialreg.h	15;"	d
CST_IEc	arch/mips/include/specialreg.h	7;"	d
CST_IEo	arch/mips/include/specialreg.h	11;"	d
CST_IEp	arch/mips/include/specialreg.h	9;"	d
CST_IRQMASK	arch/mips/include/specialreg.h	14;"	d
CST_KUc	arch/mips/include/specialreg.h	8;"	d
CST_KUo	arch/mips/include/specialreg.h	12;"	d
CST_KUp	arch/mips/include/specialreg.h	10;"	d
CST_MODEMASK	arch/mips/include/specialreg.h	13;"	d
CTLREG_IRQS	dev/lamebus/lamebus.c	17;"	d	file:
CTLREG_PWR	dev/lamebus/lamebus.c	18;"	d	file:
CTLREG_RAMSZ	dev/lamebus/lamebus.c	16;"	d	file:
DB_CACHE	include/lib.h	52;"	d
DB_DEVICE	include/lib.h	43;"	d
DB_EXEC	include/lib.h	46;"	d
DB_INTERRUPT	include/lib.h	42;"	d
DB_KMALLOC	include/lib.h	51;"	d
DB_LOCORE	include/lib.h	40;"	d
DB_NET	include/lib.h	49;"	d
DB_NETFS	include/lib.h	50;"	d
DB_SFS	include/lib.h	48;"	d
DB_SYSCALL	include/lib.h	41;"	d
DB_TEST	include/lib.h	53;"	d
DB_THREADS	include/lib.h	44;"	d
DB_TLB	include/lib.h	54;"	d
DB_VFS	include/lib.h	47;"	d
DB_VM	include/lib.h	45;"	d
DEBUG	include/lib.h	99;"	d
DEFTEST	test/fstest.c	524;"	d	file:
DELAYBUFSIZE	dev/generic/console.c	54;"	d	file:
DIM	test/tt3.c	14;"	d	file:
DIM	test/tt3.c	16;"	d	file:
DIVROUNDUP	include/lib.h	232;"	d
DUMBVM_STACKPAGES	arch/mips/mips/dumbvm.c	33;"	d	file:
E2BIG	include/kern/errno.h	37;"	d
EAGAIN	include/kern/errno.h	23;"	d
EBADF	include/kern/errno.h	38;"	d
EBUSY	include/kern/errno.h	28;"	d
EEXIST	include/kern/errno.h	21;"	d
EFAULT	include/kern/errno.h	14;"	d
EINVAL	include/kern/errno.h	13;"	d
EIO	include/kern/errno.h	17;"	d
EIOCTL	include/kern/errno.h	29;"	d
EISDIR	include/kern/errno.h	20;"	d
EI_ABIVERSION	include/elf.h	45;"	d
EI_CLASS	include/elf.h	41;"	d
EI_DATA	include/elf.h	42;"	d
EI_MAG0	include/elf.h	37;"	d
EI_MAG1	include/elf.h	38;"	d
EI_MAG2	include/elf.h	39;"	d
EI_MAG3	include/elf.h	40;"	d
EI_OSABI	include/elf.h	44;"	d
EI_PAD	include/elf.h	46;"	d
EI_VERSION	include/elf.h	43;"	d
ELFCLASS32	include/elf.h	58;"	d
ELFCLASS64	include/elf.h	59;"	d
ELFCLASSNONE	include/elf.h	57;"	d
ELFDATA2LSB	include/elf.h	63;"	d
ELFDATA2MSB	include/elf.h	64;"	d
ELFDATANONE	include/elf.h	62;"	d
ELFMAG0	include/elf.h	51;"	d
ELFMAG1	include/elf.h	52;"	d
ELFMAG2	include/elf.h	53;"	d
ELFMAG3	include/elf.h	54;"	d
ELFOSABI_HPUX	include/elf.h	72;"	d
ELFOSABI_STANDALONE	include/elf.h	73;"	d
ELFOSABI_SYSV	include/elf.h	71;"	d
ELF_NIDENT	include/elf.h	18;"	d
EMFILE	include/kern/errno.h	33;"	d
EMU_BUFFER	dev/lamebus/emu.c	36;"	d	file:
EMU_MAXIO	dev/lamebus/emu.h	4;"	d
EMU_OP_CLOSE	dev/lamebus/emu.c	42;"	d	file:
EMU_OP_CREATE	dev/lamebus/emu.c	40;"	d	file:
EMU_OP_EXCLCREATE	dev/lamebus/emu.c	41;"	d	file:
EMU_OP_GETSIZE	dev/lamebus/emu.c	46;"	d	file:
EMU_OP_OPEN	dev/lamebus/emu.c	39;"	d	file:
EMU_OP_READ	dev/lamebus/emu.c	43;"	d	file:
EMU_OP_READDIR	dev/lamebus/emu.c	44;"	d	file:
EMU_OP_TRUNC	dev/lamebus/emu.c	47;"	d	file:
EMU_OP_WRITE	dev/lamebus/emu.c	45;"	d	file:
EMU_RES_BADHANDLE	dev/lamebus/emu.c	51;"	d	file:
EMU_RES_BADOP	dev/lamebus/emu.c	52;"	d	file:
EMU_RES_BADPATH	dev/lamebus/emu.c	53;"	d	file:
EMU_RES_BADSIZE	dev/lamebus/emu.c	54;"	d	file:
EMU_RES_EXISTS	dev/lamebus/emu.c	55;"	d	file:
EMU_RES_ISDIR	dev/lamebus/emu.c	56;"	d	file:
EMU_RES_MEDIA	dev/lamebus/emu.c	57;"	d	file:
EMU_RES_NOHANDLES	dev/lamebus/emu.c	58;"	d	file:
EMU_RES_NOSPACE	dev/lamebus/emu.c	59;"	d	file:
EMU_RES_NOTDIR	dev/lamebus/emu.c	60;"	d	file:
EMU_RES_SUCCESS	dev/lamebus/emu.c	50;"	d	file:
EMU_RES_UNKNOWN	dev/lamebus/emu.c	61;"	d	file:
EMU_RES_UNSUPP	dev/lamebus/emu.c	62;"	d	file:
EMU_ROOTHANDLE	dev/lamebus/emu.h	5;"	d
EM_386	include/elf.h	92;"	d
EM_486	include/elf.h	95;"	d
EM_68HC12	include/elf.h	124;"	d
EM_68K	include/elf.h	93;"	d
EM_860	include/elf.h	96;"	d
EM_88K	include/elf.h	94;"	d
EM_960	include/elf.h	105;"	d
EM_ALPHA	include/elf.h	112;"	d
EM_ALPHA_EXP	include/elf.h	126;"	d
EM_ARC	include/elf.h	116;"	d
EM_ARM	include/elf.h	111;"	d
EM_COLDFIRE	include/elf.h	123;"	d
EM_FR20	include/elf.h	108;"	d
EM_H8S	include/elf.h	119;"	d
EM_H8_300	include/elf.h	117;"	d
EM_H8_300H	include/elf.h	118;"	d
EM_H8_500	include/elf.h	120;"	d
EM_IA_64	include/elf.h	121;"	d
EM_M32	include/elf.h	90;"	d
EM_MACHINE	arch/mips/include/vm.h	77;"	d
EM_MIPS	include/elf.h	97;"	d
EM_MIPS_RS3_LE	include/elf.h	99;"	d
EM_MIPS_X	include/elf.h	122;"	d
EM_NCUBE	include/elf.h	102;"	d
EM_NONE	include/elf.h	89;"	d
EM_NUM	include/elf.h	127;"	d
EM_PARISC	include/elf.h	101;"	d
EM_PPC	include/elf.h	106;"	d
EM_RCE	include/elf.h	110;"	d
EM_RH32	include/elf.h	109;"	d
EM_RS6000	include/elf.h	100;"	d
EM_S370	include/elf.h	98;"	d
EM_SH	include/elf.h	113;"	d
EM_SPARC	include/elf.h	91;"	d
EM_SPARC32PLUS	include/elf.h	104;"	d
EM_SPARCV9	include/elf.h	114;"	d
EM_TRICORE	include/elf.h	115;"	d
EM_V800	include/elf.h	107;"	d
EM_VAX	include/elf.h	125;"	d
EM_VPP500	include/elf.h	103;"	d
ENAMETOOLONG	include/kern/errno.h	15;"	d
ENFILE	include/kern/errno.h	34;"	d
ENODEV	include/kern/errno.h	27;"	d
ENOENT	include/kern/errno.h	18;"	d
ENOEXEC	include/kern/errno.h	36;"	d
ENOMEM	include/kern/errno.h	16;"	d
ENOSPC	include/kern/errno.h	32;"	d
ENOSYS	include/kern/errno.h	35;"	d
ENOTDIR	include/kern/errno.h	19;"	d
ENOTEMPTY	include/kern/errno.h	30;"	d
ENXIO	include/kern/errno.h	26;"	d
ERANGE	include/kern/errno.h	31;"	d
ESPIPE	include/kern/errno.h	24;"	d
ET_CORE	include/elf.h	83;"	d
ET_DYN	include/elf.h	82;"	d
ET_EXEC	include/elf.h	81;"	d
ET_NONE	include/elf.h	79;"	d
ET_NUM	include/elf.h	84;"	d
ET_REL	include/elf.h	80;"	d
EUNIMP	include/kern/errno.h	25;"	d
EV_CURRENT	include/elf.h	68;"	d
EV_NONE	include/elf.h	67;"	d
EXDEV	include/kern/errno.h	22;"	d
EX_ADEL	arch/mips/include/trapframe.h	58;"	d
EX_ADES	arch/mips/include/trapframe.h	59;"	d
EX_BP	arch/mips/include/trapframe.h	63;"	d
EX_CPU	arch/mips/include/trapframe.h	65;"	d
EX_DBE	arch/mips/include/trapframe.h	61;"	d
EX_IBE	arch/mips/include/trapframe.h	60;"	d
EX_IRQ	arch/mips/include/trapframe.h	54;"	d
EX_MOD	arch/mips/include/trapframe.h	55;"	d
EX_OVF	arch/mips/include/trapframe.h	66;"	d
EX_RI	arch/mips/include/trapframe.h	64;"	d
EX_SYS	arch/mips/include/trapframe.h	62;"	d
EX_TLBL	arch/mips/include/trapframe.h	56;"	d
EX_TLBS	arch/mips/include/trapframe.h	57;"	d
Elf32_Ehdr	include/elf.h	/^} Elf32_Ehdr;$/;"	t	typeref:struct:__anon3
Elf32_Phdr	include/elf.h	/^} Elf32_Phdr;$/;"	t	typeref:struct:__anon4
Elf_Ehdr	include/elf.h	/^typedef Elf32_Ehdr Elf_Ehdr;$/;"	t
Elf_Phdr	include/elf.h	/^typedef Elf32_Phdr Elf_Phdr;$/;"	t
FALSE	include/lib.h	236;"	d
FILENAME	test/fstest.c	25;"	d	file:
FSOP_GETROOT	include/fs.h	47;"	d
FSOP_GETVOLNAME	include/fs.h	46;"	d
FSOP_SYNC	include/fs.h	45;"	d
FSOP_UNMOUNT	include/fs.h	48;"	d
GROUP_VERSION	include/version.h	13;"	d
HIGH_VERSION	dev/lamebus/emu_att.c	14;"	d	file:
HIGH_VERSION	dev/lamebus/lhd_att.c	13;"	d	file:
HIGH_VERSION	dev/lamebus/lnet_att.c	9;"	d	file:
HIGH_VERSION	dev/lamebus/lrandom_att.c	10;"	d	file:
HIGH_VERSION	dev/lamebus/lscreen_att.c	13;"	d	file:
HIGH_VERSION	dev/lamebus/lser_att.c	10;"	d	file:
HIGH_VERSION	dev/lamebus/ltimer_att.c	13;"	d	file:
HIGH_VERSION	dev/lamebus/ltrace_att.c	10;"	d	file:
HZ	include/clock.h	15;"	d
HZ	include/clock.h	18;"	d
INCDIR	Makefile	/^INCDIR=$(OSTREE)\/include$/;"	m
INUSE_WORDS	lib/kheap.c	109;"	d	file:
INVALID_OFFSET	lib/kheap.c	80;"	d	file:
INVALID_PID	include/pid.h	9;"	d
ISDIR	dev/lamebus/emu.c	833;"	d	file:
ISDIR	fs/sfs/sfs_vnode.c	1467;"	d	file:
ITEMSIZE	test/malloctest.c	22;"	d	file:
K1	dev/generic/pseudorand.c	17;"	d	file:
K2	dev/generic/pseudorand.c	18;"	d	file:
KINCDIR	Makefile	/^KINCDIR=$(OSTREE)\/include\/kern$/;"	m
KVADDR_TO_PADDR	arch/mips/include/vm.h	37;"	d
LAMEBUS_IRQ_BIT	arch/mips/mips/interrupt.c	15;"	d	file:
LAMEBUS_NMI_BIT	arch/mips/mips/interrupt.c	16;"	d	file:
LARGEST_SUBPAGE_SIZE	lib/kheap.c	58;"	d	file:
LBCS161_BUSCTL	dev/lamebus/lamebus.h	13;"	d
LBCS161_DISK	dev/lamebus/lamebus.h	15;"	d
LBCS161_EMUFS	dev/lamebus/lamebus.h	19;"	d
LBCS161_NET	dev/lamebus/lamebus.h	18;"	d
LBCS161_RANDOM	dev/lamebus/lamebus.h	21;"	d
LBCS161_SCREEN	dev/lamebus/lamebus.h	17;"	d
LBCS161_SERIAL	dev/lamebus/lamebus.h	16;"	d
LBCS161_TIMER	dev/lamebus/lamebus.h	14;"	d
LBCS161_TRACE	dev/lamebus/lamebus.h	20;"	d
LB_BASEADDR	arch/mips/include/bus.h	28;"	d
LB_CONFIG_SIZE	dev/lamebus/lamebus.h	30;"	d
LB_CONTROLLER_SLOT	dev/lamebus/lamebus.h	24;"	d
LB_NSLOTS	dev/lamebus/lamebus.h	27;"	d
LB_SLOT_SIZE	dev/lamebus/lamebus.h	33;"	d
LB_VENDOR_CS161	dev/lamebus/lamebus.h	10;"	d
LHD_BUFFER	dev/lamebus/lhd.c	31;"	d	file:
LHD_IDLE	dev/lamebus/lhd.c	22;"	d	file:
LHD_INVSECT	dev/lamebus/lhd.c	25;"	d	file:
LHD_ISWRITE	dev/lamebus/lhd.c	27;"	d	file:
LHD_MEDIA	dev/lamebus/lhd.c	26;"	d	file:
LHD_OK	dev/lamebus/lhd.c	24;"	d	file:
LHD_REG_NSECT	dev/lamebus/lhd.c	16;"	d	file:
LHD_REG_RPM	dev/lamebus/lhd.c	19;"	d	file:
LHD_REG_SECT	dev/lamebus/lhd.c	18;"	d	file:
LHD_REG_STAT	dev/lamebus/lhd.c	17;"	d	file:
LHD_SECTSIZE	dev/lamebus/lhd.h	9;"	d
LHD_STATEMASK	dev/lamebus/lhd.c	28;"	d	file:
LHD_WORKING	dev/lamebus/lhd.c	23;"	d	file:
LOW_VERSION	dev/lamebus/emu_att.c	12;"	d	file:
LOW_VERSION	dev/lamebus/lhd_att.c	11;"	d	file:
LOW_VERSION	dev/lamebus/lnet_att.c	7;"	d	file:
LOW_VERSION	dev/lamebus/lrandom_att.c	8;"	d	file:
LOW_VERSION	dev/lamebus/lscreen_att.c	11;"	d	file:
LOW_VERSION	dev/lamebus/lser_att.c	8;"	d	file:
LOW_VERSION	dev/lamebus/ltimer_att.c	11;"	d	file:
LOW_VERSION	dev/lamebus/ltrace_att.c	8;"	d	file:
LR_RANDMAX	dev/lamebus/lrandom.c	15;"	d	file:
LR_REG_RAND	dev/lamebus/lrandom.c	12;"	d	file:
LSCR_IRQ_ACTIVE	dev/lamebus/lscreen.c	22;"	d	file:
LSCR_IRQ_ENABLE	dev/lamebus/lscreen.c	21;"	d	file:
LSCR_REG_CHAR	dev/lamebus/lscreen.c	17;"	d	file:
LSCR_REG_POSN	dev/lamebus/lscreen.c	15;"	d	file:
LSCR_REG_RIRQ	dev/lamebus/lscreen.c	18;"	d	file:
LSCR_REG_SIZE	dev/lamebus/lscreen.c	16;"	d	file:
LSCR_SCREEN	dev/lamebus/lscreen.c	25;"	d	file:
LSER_IRQ_ACTIVE	dev/lamebus/lser.c	15;"	d	file:
LSER_IRQ_ENABLE	dev/lamebus/lser.c	14;"	d	file:
LSER_REG_CHAR	dev/lamebus/lser.c	9;"	d	file:
LSER_REG_RIRQ	dev/lamebus/lser.c	11;"	d	file:
LSER_REG_WIRQ	dev/lamebus/lser.c	10;"	d	file:
LTRACE_REG_DEBUG	dev/lamebus/ltrace.c	10;"	d	file:
LTRACE_REG_DUMP	dev/lamebus/ltrace.c	11;"	d	file:
LTRACE_REG_TROFF	dev/lamebus/ltrace.c	9;"	d	file:
LTRACE_REG_TRON	dev/lamebus/ltrace.c	8;"	d	file:
LT_GRANULARITY	dev/lamebus/ltimer.c	20;"	d	file:
LT_REG_COUNT	dev/lamebus/ltimer.c	16;"	d	file:
LT_REG_IRQ	dev/lamebus/ltimer.c	15;"	d	file:
LT_REG_NSEC	dev/lamebus/ltimer.c	13;"	d	file:
LT_REG_ROE	dev/lamebus/ltimer.c	14;"	d	file:
LT_REG_SEC	dev/lamebus/ltimer.c	12;"	d	file:
LT_REG_SPKR	dev/lamebus/ltimer.c	17;"	d	file:
MAKENAME	test/fstest.c	81;"	d	file:
MAXMENUARGS	main/menu.c	22;"	d	file:
MDHEADERS	Makefile	/^MDHEADERS=asmdefs.h setjmp.h types.h$/;"	m
MDINCDIR	Makefile	/^MDINCDIR=$(OSTREE)\/include\/$(PLATFORM)$/;"	m
MIPS_KSEG0	arch/mips/include/vm.h	20;"	d
MIPS_KSEG1	arch/mips/include/vm.h	21;"	d
MIPS_KSEG2	arch/mips/include/vm.h	22;"	d
MIPS_KUSEG	arch/mips/include/vm.h	19;"	d
MKPAB	lib/kheap.c	84;"	d	file:
MODULUS	dev/generic/pseudorand.c	16;"	d	file:
MULTIPLIER	dev/generic/pseudorand.c	15;"	d	file:
NAME_MAX	include/kern/limits.h	5;"	d
NARG_MAX	include/kern/limits.h	24;"	d
NBLOCKS	test/buffertest2.c	40;"	d	file:
NBUFS	include/cache.h	3;"	d
NCHUNKS	test/fstest.c	26;"	d	file:
NCREATES	test/fstest.c	28;"	d	file:
NCVLOOPS	test/synchtest.c	14;"	d	file:
NLOCKLOOPS	test/synchtest.c	13;"	d	file:
NOTDIR	dev/lamebus/emu.c	834;"	d	file:
NOTDIR	fs/sfs/sfs_vnode.c	1468;"	d	file:
NPAGEREFS	lib/kheap.c	106;"	d	file:
NSEMLOOPS	test/synchtest.c	12;"	d	file:
NSIZES	lib/kheap.c	54;"	d	file:
NTHREADS	test/fstest.c	27;"	d	file:
NTHREADS	test/jointest.c	12;"	d	file:
NTHREADS	test/malloctest.c	23;"	d	file:
NTHREADS	test/synchtest.c	15;"	d	file:
NTHREADS	test/threadtest.c	10;"	d	file:
NTRAPCODES	arch/mips/mips/trap.c	17;"	d	file:
NTRIES	test/buffertest2.c	41;"	d	file:
NTRIES	test/malloctest.c	21;"	d	file:
NULL	arch/mips/include/types.h	57;"	d
NULL	arch/mips/include/types.h	58;"	d
NUM_TLB	arch/mips/include/tlb.h	73;"	d
NWAITADDRS	test/tt3.c	27;"	d	file:
O_ACCMODE	include/kern/unistd.h	19;"	d
O_APPEND	include/kern/unistd.h	16;"	d
O_CREAT	include/kern/unistd.h	13;"	d
O_EXCL	include/kern/unistd.h	14;"	d
O_RDONLY	include/kern/unistd.h	9;"	d
O_RDWR	include/kern/unistd.h	11;"	d
O_TRUNC	include/kern/unistd.h	15;"	d
O_WRONLY	include/kern/unistd.h	10;"	d
P	thread/synch.c	/^P(struct semaphore *sem)$/;"	f
PADDR_TO_KVADDR	arch/mips/include/vm.h	36;"	d
PAGE_FRAME	arch/mips/include/vm.h	9;"	d
PAGE_SIZE	arch/mips/include/vm.h	8;"	d
PATH_MAX	include/kern/limits.h	8;"	d
PF_R	include/elf.h	159;"	d
PF_W	include/elf.h	160;"	d
PF_X	include/elf.h	161;"	d
PID_MAX	include/kern/limits.h	15;"	d
PID_MIN	include/kern/limits.h	12;"	d
PROCS_MAX	include/kern/limits.h	18;"	d
PR_BLOCKTYPE	lib/kheap.c	83;"	d	file:
PR_PAGEADDR	lib/kheap.c	82;"	d	file:
PT_DYNAMIC	include/elf.h	150;"	d
PT_INTERP	include/elf.h	151;"	d
PT_LOAD	include/elf.h	149;"	d
PT_MIPS_REGINFO	include/elf.h	156;"	d
PT_NOTE	include/elf.h	152;"	d
PT_NULL	include/elf.h	148;"	d
PT_NUM	include/elf.h	155;"	d
PT_PHDR	include/elf.h	154;"	d
PT_SHLIB	include/elf.h	153;"	d
RAND_MAX	include/lib.h	105;"	d
RB_HALT	include/kern/unistd.h	29;"	d
RB_POWEROFF	include/kern/unistd.h	30;"	d
RB_REBOOT	include/kern/unistd.h	28;"	d
REG_HANDLE	dev/lamebus/emu.c	29;"	d	file:
REG_IOLEN	dev/lamebus/emu.c	31;"	d	file:
REG_OFFSET	dev/lamebus/emu.c	30;"	d	file:
REG_OPER	dev/lamebus/emu.c	32;"	d	file:
REG_RESULT	dev/lamebus/emu.c	33;"	d	file:
ROUNDUP	include/lib.h	233;"	d
SAME_STACK	arch/mips/include/pcb.h	17;"	d
SEEK_CUR	include/kern/unistd.h	34;"	d
SEEK_END	include/kern/unistd.h	35;"	d
SEEK_SET	include/kern/unistd.h	33;"	d
SFSUIO	include/sfs.h	44;"	d
SFS_BITBLOCKS	include/kern/sfs.h	25;"	d
SFS_BITMAPSIZE	include/kern/sfs.h	22;"	d
SFS_BLOCKBITS	include/kern/sfs.h	16;"	d
SFS_BLOCKSIZE	include/kern/sfs.h	5;"	d
SFS_DBPERIDB	include/kern/sfs.h	8;"	d
SFS_FS_BITBLOCKS	fs/sfs/sfs_fs.c	19;"	d	file:
SFS_FS_BITMAPSIZE	fs/sfs/sfs_fs.c	18;"	d	file:
SFS_MAGIC	include/kern/sfs.h	4;"	d
SFS_MAP_LOCATION	include/kern/sfs.h	12;"	d
SFS_NAMELEN	include/kern/sfs.h	9;"	d
SFS_NDIRECT	include/kern/sfs.h	7;"	d
SFS_NOINO	include/kern/sfs.h	13;"	d
SFS_ROOT_LOCATION	include/kern/sfs.h	11;"	d
SFS_ROUNDUP	include/kern/sfs.h	19;"	d
SFS_SB_LOCATION	include/kern/sfs.h	10;"	d
SFS_TYPE_DIR	include/kern/sfs.h	30;"	d
SFS_TYPE_FILE	include/kern/sfs.h	29;"	d
SFS_TYPE_INVAL	include/kern/sfs.h	28;"	d
SFS_VOLNAME_SIZE	include/kern/sfs.h	6;"	d
SLEEPALOT_ITERS	test/tt3.c	21;"	d	file:
SLEEPALOT_PRINTS	test/tt3.c	20;"	d	file:
SLOGAN	test/fstest.c	24;"	d	file:
SLOW	lib/kheap.c	162;"	d	file:
SLOW	lib/kheap.c	47;"	d	file:
SLOWER	lib/kheap.c	48;"	d	file:
SMALLEST_SUBPAGE_SIZE	lib/kheap.c	57;"	d	file:
SPL_HIGH	arch/mips/include/spl.h	64;"	d
STACK_MASK	arch/mips/include/pcb.h	14;"	d
STACK_SIZE	arch/mips/include/pcb.h	11;"	d
STDERR_FILENO	include/kern/unistd.h	25;"	d
STDIN_FILENO	include/kern/unistd.h	23;"	d
STDOUT_FILENO	include/kern/unistd.h	24;"	d
SWAPFUNCS	lib/ntoh.c	22;"	d	file:
SWAPFUNCS	lib/ntoh.c	52;"	d	file:
SYS___getcwd	include/kern/callno.h	40;"	d
SYS___time	include/kern/callno.h	39;"	d
SYS__exit	include/kern/callno.h	11;"	d
SYS_chdir	include/kern/callno.h	33;"	d
SYS_close	include/kern/callno.h	18;"	d
SYS_dup2	include/kern/callno.h	37;"	d
SYS_execv	include/kern/callno.h	12;"	d
SYS_fork	include/kern/callno.h	13;"	d
SYS_fstat	include/kern/callno.h	27;"	d
SYS_fsync	include/kern/callno.h	25;"	d
SYS_ftruncate	include/kern/callno.h	26;"	d
SYS_getdirentry	include/kern/callno.h	34;"	d
SYS_getpid	include/kern/callno.h	22;"	d
SYS_ioctl	include/kern/callno.h	23;"	d
SYS_link	include/kern/callno.h	30;"	d
SYS_lseek	include/kern/callno.h	24;"	d
SYS_lstat	include/kern/callno.h	42;"	d
SYS_mkdir	include/kern/callno.h	31;"	d
SYS_open	include/kern/callno.h	15;"	d
SYS_pipe	include/kern/callno.h	38;"	d
SYS_printchar	include/kern/callno.h	44;"	d
SYS_read	include/kern/callno.h	16;"	d
SYS_readlink	include/kern/callno.h	36;"	d
SYS_reboot	include/kern/callno.h	19;"	d
SYS_remove	include/kern/callno.h	28;"	d
SYS_rename	include/kern/callno.h	29;"	d
SYS_rmdir	include/kern/callno.h	32;"	d
SYS_sbrk	include/kern/callno.h	21;"	d
SYS_stat	include/kern/callno.h	41;"	d
SYS_symlink	include/kern/callno.h	35;"	d
SYS_sync	include/kern/callno.h	20;"	d
SYS_waitpid	include/kern/callno.h	14;"	d
SYS_write	include/kern/callno.h	17;"	d
S_IFBLK	include/kern/stat.h	27;"	d
S_IFCHR	include/kern/stat.h	26;"	d
S_IFDIR	include/kern/stat.h	24;"	d
S_IFLNK	include/kern/stat.h	25;"	d
S_IFMT	include/kern/stat.h	22;"	d
S_IFREG	include/kern/stat.h	23;"	d
S_ISBLK	include/kern/stat.h	36;"	d
S_ISCHR	include/kern/stat.h	35;"	d
S_ISDIR	include/kern/stat.h	33;"	d
S_ISLNK	include/kern/stat.h	34;"	d
S_ISREG	include/kern/stat.h	32;"	d
S_READY	thread/thread.c	/^	S_READY,$/;"	e	enum:__anon1	file:
S_RUN	thread/thread.c	/^	S_RUN,$/;"	e	enum:__anon1	file:
S_SLEEP	thread/thread.c	/^	S_SLEEP,$/;"	e	enum:__anon1	file:
S_ZOMB	thread/thread.c	/^	S_ZOMB,$/;"	e	enum:__anon1	file:
TESTSIZE	test/arraytest.c	6;"	d	file:
TESTSIZE	test/bitmaptest.c	6;"	d	file:
TLBHI_INVALID	arch/mips/include/tlb.h	66;"	d
TLBHI_VPAGE	arch/mips/include/tlb.h	51;"	d
TLBLO_DIRTY	arch/mips/include/tlb.h	57;"	d
TLBLO_INVALID	arch/mips/include/tlb.h	67;"	d
TLBLO_NOCACHE	arch/mips/include/tlb.h	56;"	d
TLBLO_PPAGE	arch/mips/include/tlb.h	55;"	d
TLBLO_VALID	arch/mips/include/tlb.h	58;"	d
TLB_Probe	arch/mips/mips/tlb_mips1.S	/^TLB_Probe:$/;"	l
TLB_Random	arch/mips/mips/tlb_mips1.S	/^TLB_Random:$/;"	l
TLB_Read	arch/mips/mips/tlb_mips1.S	/^TLB_Read:$/;"	l
TLB_Reset	arch/mips/mips/tlb_mips1.S	/^TLB_Reset:$/;"	l
TLB_Write	arch/mips/mips/tlb_mips1.S	/^TLB_Write:$/;"	l
TRUE	include/lib.h	235;"	d
UIO_READ	include/uio.h	/^	UIO_READ,$/;"	e	enum:uio_rw
UIO_SYSSPACE	include/uio.h	/^	UIO_SYSSPACE,$/;"	e	enum:uio_seg
UIO_USERISPACE	include/uio.h	/^	UIO_USERISPACE,$/;"	e	enum:uio_seg
UIO_USERSPACE	include/uio.h	/^	UIO_USERSPACE,$/;"	e	enum:uio_seg
UIO_WRITE	include/uio.h	/^	UIO_WRITE,$/;"	e	enum:uio_rw
UNIMP	dev/lamebus/emu.c	835;"	d	file:
UNIMP	fs/sfs/sfs_vnode.c	1469;"	d	file:
USERSTACK	arch/mips/include/vm.h	53;"	d
USERTOP	arch/mips/include/vm.h	43;"	d
V	thread/synch.c	/^V(struct semaphore *sem)$/;"	f
VM_FAULT_READ	include/vm.h	14;"	d
VM_FAULT_READONLY	include/vm.h	16;"	d
VM_FAULT_WRITE	include/vm.h	15;"	d
VOP_CLOSE	include/vnode.h	216;"	d
VOP_CREAT	include/vnode.h	232;"	d
VOP_DECOPEN	include/vnode.h	267;"	d
VOP_DECREF	include/vnode.h	255;"	d
VOP_FSYNC	include/vnode.h	227;"	d
VOP_GETDIRENTRY	include/vnode.h	221;"	d
VOP_GETTYPE	include/vnode.h	225;"	d
VOP_INCOPEN	include/vnode.h	266;"	d
VOP_INCREF	include/vnode.h	254;"	d
VOP_INIT	include/vnode.h	276;"	d
VOP_IOCTL	include/vnode.h	223;"	d
VOP_KILL	include/vnode.h	284;"	d
VOP_LINK	include/vnode.h	235;"	d
VOP_LOOKPARENT	include/vnode.h	241;"	d
VOP_LOOKUP	include/vnode.h	240;"	d
VOP_MAGIC	include/vnode.h	164;"	d
VOP_MKDIR	include/vnode.h	234;"	d
VOP_MMAP	include/vnode.h	228;"	d
VOP_NAMEFILE	include/vnode.h	230;"	d
VOP_OPEN	include/vnode.h	215;"	d
VOP_READ	include/vnode.h	219;"	d
VOP_READLINK	include/vnode.h	220;"	d
VOP_RECLAIM	include/vnode.h	217;"	d
VOP_REMOVE	include/vnode.h	236;"	d
VOP_RENAME	include/vnode.h	238;"	d
VOP_RMDIR	include/vnode.h	237;"	d
VOP_STAT	include/vnode.h	224;"	d
VOP_SYMLINK	include/vnode.h	233;"	d
VOP_TRUNCATE	include/vnode.h	229;"	d
VOP_TRYSEEK	include/vnode.h	226;"	d
VOP_WRITE	include/vnode.h	222;"	d
WAKER_WAKES	test/tt3.c	23;"	d	file:
WORD_ALLBITS	include/bitmap.h	29;"	d
WORD_TYPE	include/bitmap.h	28;"	d
_ADDRSPACE_H_	include/addrspace.h	2;"	d
_ARRAY_H_	include/array.h	2;"	d
_BIG_ENDIAN	arch/mips/include/types.h	66;"	d
_BITMAP_H_	include/bitmap.h	2;"	d
_CLOCK_H_	include/clock.h	2;"	d
_CURTHREAD_H_	include/curthread.h	2;"	d
_DEV_H_	include/dev.h	2;"	d
_ELF_H_	include/elf.h	2;"	d
_EMUFS_H_	include/emufs.h	2;"	d
_FS_H_	include/fs.h	2;"	d
_GENERIC_BEEP_H_	dev/generic/beep.h	2;"	d
_GENERIC_CONSOLE_H_	dev/generic/console.h	2;"	d
_GENERIC_PSEUDORAND_H_	dev/generic/pseudorand.h	2;"	d
_GENERIC_RANDOM_H_	dev/generic/random.h	2;"	d
_GENERIC_RTCLOCK_H_	dev/generic/rtclock.h	2;"	d
_KERN_CALLNO_H_	include/kern/callno.h	2;"	d
_KERN_ERRMSG_H_	include/kern/errmsg.h	2;"	d
_KERN_ERRNO_H_	include/kern/errno.h	2;"	d
_KERN_IOCTL_H_	include/kern/ioctl.h	2;"	d
_KERN_LIMITS_H_	include/kern/limits.h	2;"	d
_KERN_SFS_H_	include/kern/sfs.h	2;"	d
_KERN_STAT_H_	include/kern/stat.h	2;"	d
_KERN_TYPES_H_	include/kern/types.h	2;"	d
_KERN_UNISTD_H_	include/kern/unistd.h	2;"	d
_LAMEBUS_EMU_H_	dev/lamebus/emu.h	2;"	d
_LAMEBUS_H_	dev/lamebus/lamebus.h	2;"	d
_LAMEBUS_LHD_H_	dev/lamebus/lhd.h	2;"	d
_LAMEBUS_LRANDOM_H_	dev/lamebus/lrandom.h	2;"	d
_LAMEBUS_LSCREEN_H_	dev/lamebus/lscreen.h	2;"	d
_LAMEBUS_LSER_H_	dev/lamebus/lser.h	2;"	d
_LAMEBUS_LTIMER_H_	dev/lamebus/ltimer.h	2;"	d
_LAMEBUS_LTRACE_H_	dev/lamebus/ltrace.h	2;"	d
_LIB_H_	include/lib.h	2;"	d
_LITTLE_ENDIAN	arch/mips/include/types.h	65;"	d
_MACHINE_PCB_H_	arch/mips/include/pcb.h	6;"	d
_MACHINE_SPL_H_	arch/mips/include/spl.h	2;"	d
_MACHINE_TLB_H_	arch/mips/include/tlb.h	2;"	d
_MIPS_ASMDEFS_H_	arch/mips/include/asmdefs.h	5;"	d
_MIPS_BUS_H_	arch/mips/include/bus.h	2;"	d
_MIPS_KTYPES_H_	arch/mips/include/ktypes.h	2;"	d
_MIPS_SETJMP_H_	arch/mips/include/setjmp.h	2;"	d
_MIPS_SPECIALREG_H_	arch/mips/include/specialreg.h	2;"	d
_MIPS_SWITCHFRAME_H_	arch/mips/include/switchframe.h	2;"	d
_MIPS_TRAPFRAME_H_	arch/mips/include/trapframe.h	2;"	d
_MIPS_TYPES_H_	arch/mips/include/types.h	2;"	d
_MIPS_VM_H_	arch/mips/include/vm.h	2;"	d
_PATH_SHELL	main/menu.c	20;"	d	file:
_PID_H_	include/pid.h	7;"	d
_QUEUE_H_	include/queue.h	2;"	d
_SCHEDULER_H_	include/scheduler.h	2;"	d
_SFS_H_	include/sfs.h	2;"	d
_STDARG_H_	include/stdarg.h	2;"	d
_SYNCH_H_	include/synch.h	6;"	d
_SYSCALL_H_	include/syscall.h	2;"	d
_TEST_H_	include/test.h	2;"	d
_THREAD_H_	include/thread.h	2;"	d
_TYPES_H_	include/types.h	2;"	d
_UIO_H_	include/uio.h	2;"	d
_VERSION_H_	include/version.h	2;"	d
_VFS_H_	include/vfs.h	2;"	d
_VM_H_	include/vm.h	2;"	d
_VNODE_H_	include/vnode.h	2;"	d
__JB_REGS	arch/mips/include/setjmp.h	8;"	d
__PF	include/lib.h	15;"	d
__PF	include/lib.h	17;"	d
__PRETTY_FUNCTION__	include/lib.h	24;"	d
__VOP	include/vnode.h	213;"	d
__start	arch/mips/mips/start.S	/^__start:$/;"	l
__userptr	include/types.h	/^struct __userptr { char _dummy; };$/;"	s
__va_list	include/stdarg.h	/^typedef __builtin_va_list __va_list;$/;"	t
_dummy	include/types.h	/^struct __userptr { char _dummy; };$/;"	m	struct:__userptr
a0	arch/mips/include/asmdefs.h	14;"	d
a1	arch/mips/include/asmdefs.h	15;"	d
a2	arch/mips/include/asmdefs.h	16;"	d
a3	arch/mips/include/asmdefs.h	17;"	d
addrspace	include/addrspace.h	/^struct addrspace {$/;"	s
all_busy_cv	include/cache.h	/^  struct cv *all_busy_cv; \/* wait for victim if all buffers are doing io *\/$/;"	m	struct:cache	typeref:struct:cache::cv
allbase	lib/kheap.c	/^static struct pageref *allbase;$/;"	v	typeref:struct:pageref	file:
alloc_kpages	arch/mips/mips/dumbvm.c	/^alloc_kpages(int npages)$/;"	f
allocpageref	lib/kheap.c	/^allocpageref(void)$/;"	f	file:
array	lib/array.c	/^struct array {$/;"	s	file:
array_add	lib/array.c	/^array_add(struct array *a, void *guy)$/;"	f
array_create	lib/array.c	/^array_create(void)$/;"	f
array_destroy	lib/array.c	/^array_destroy(struct array *a)$/;"	f
array_getguy	lib/array.c	/^array_getguy(struct array *a, int index)$/;"	f
array_getnum	lib/array.c	/^array_getnum(struct array *a)$/;"	f
array_preallocate	lib/array.c	/^array_preallocate(struct array *a, int nguys)$/;"	f
array_remove	lib/array.c	/^array_remove(struct array *a, int index)$/;"	f
array_setguy	lib/array.c	/^array_setguy(struct array *a, int index, void *ptr)$/;"	f
array_setsize	lib/array.c	/^array_setsize(struct array *a, int nguys)$/;"	f
arraytest	test/arraytest.c	/^arraytest(int nargs, char **args)$/;"	f
as_activate	arch/mips/mips/dumbvm.c	/^as_activate(struct addrspace *as)$/;"	f
as_activate	vm/addrspace.c	/^as_activate(struct addrspace *as)$/;"	f
as_complete_load	arch/mips/mips/dumbvm.c	/^as_complete_load(struct addrspace *as)$/;"	f
as_complete_load	vm/addrspace.c	/^as_complete_load(struct addrspace *as)$/;"	f
as_copy	arch/mips/mips/dumbvm.c	/^as_copy(struct addrspace *old, struct addrspace **ret)$/;"	f
as_copy	vm/addrspace.c	/^as_copy(struct addrspace *old, struct addrspace **ret)$/;"	f
as_create	arch/mips/mips/dumbvm.c	/^as_create(void)$/;"	f
as_create	vm/addrspace.c	/^as_create(void)$/;"	f
as_define_region	arch/mips/mips/dumbvm.c	/^as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,$/;"	f
as_define_region	vm/addrspace.c	/^as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,$/;"	f
as_define_stack	arch/mips/mips/dumbvm.c	/^as_define_stack(struct addrspace *as, vaddr_t *stackptr)$/;"	f
as_define_stack	vm/addrspace.c	/^as_define_stack(struct addrspace *as, vaddr_t *stackptr)$/;"	f
as_destroy	arch/mips/mips/dumbvm.c	/^as_destroy(struct addrspace *as)$/;"	f
as_destroy	vm/addrspace.c	/^as_destroy(struct addrspace *as)$/;"	f
as_npages1	include/addrspace.h	/^	size_t as_npages1;$/;"	m	struct:addrspace
as_npages2	include/addrspace.h	/^	size_t as_npages2;$/;"	m	struct:addrspace
as_pbase1	include/addrspace.h	/^	paddr_t as_pbase1;$/;"	m	struct:addrspace
as_pbase2	include/addrspace.h	/^	paddr_t as_pbase2;$/;"	m	struct:addrspace
as_prepare_load	arch/mips/mips/dumbvm.c	/^as_prepare_load(struct addrspace *as)$/;"	f
as_prepare_load	vm/addrspace.c	/^as_prepare_load(struct addrspace *as)$/;"	f
as_stackpbase	include/addrspace.h	/^	paddr_t as_stackpbase;$/;"	m	struct:addrspace
as_vbase1	include/addrspace.h	/^	vaddr_t as_vbase1;$/;"	m	struct:addrspace
as_vbase2	include/addrspace.h	/^	vaddr_t as_vbase2;$/;"	m	struct:addrspace
asm_usermode	arch/mips/mips/exception.S	/^asm_usermode:$/;"	l
assert	include/lib.h	30;"	d
attach_beep_to_ltimer	dev/lamebus/beep_ltimer.c	/^attach_beep_to_ltimer(int beepno, struct ltimer_softc *ls)$/;"	f
attach_con_to_lscreen	dev/lamebus/con_lscreen.c	/^attach_con_to_lscreen(int consno, struct lscreen_softc *ls)$/;"	f
attach_con_to_lser	dev/lamebus/con_lser.c	/^attach_con_to_lser(int consno, struct lser_softc *ls)$/;"	f
attach_console_to_vfs	dev/generic/console.c	/^attach_console_to_vfs(struct con_softc *cs)$/;"	f	file:
attach_emu_to_lamebus	dev/lamebus/emu_att.c	/^attach_emu_to_lamebus(int emuno, struct lamebus_softc *sc)$/;"	f
attach_lhd_to_lamebus	dev/lamebus/lhd_att.c	/^attach_lhd_to_lamebus(int lhdno, struct lamebus_softc *sc)$/;"	f
attach_lnet_to_lamebus	dev/lamebus/lnet_att.c	/^attach_lnet_to_lamebus(int lnetno, struct lamebus_softc *sc)$/;"	f
attach_lrandom_to_lamebus	dev/lamebus/lrandom_att.c	/^attach_lrandom_to_lamebus(int lrandomno, struct lamebus_softc *sc)$/;"	f
attach_lscreen_to_lamebus	dev/lamebus/lscreen_att.c	/^attach_lscreen_to_lamebus(int lscreenno, struct lamebus_softc *sc)$/;"	f
attach_lser_to_lamebus	dev/lamebus/lser_att.c	/^attach_lser_to_lamebus(int lserno, struct lamebus_softc *sc)$/;"	f
attach_ltimer_to_lamebus	dev/lamebus/ltimer_att.c	/^attach_ltimer_to_lamebus(int ltimerno, struct lamebus_softc *sc)$/;"	f
attach_ltrace_to_lamebus	dev/lamebus/ltrace_att.c	/^attach_ltrace_to_lamebus(int ltraceno, struct lamebus_softc *sc)$/;"	f
attach_random_to_lrandom	dev/lamebus/random_lrandom.c	/^attach_random_to_lrandom(int randomno, struct lrandom_softc *ls)$/;"	f
attach_random_to_pseudorand	dev/generic/pseudorand_att.c	/^attach_random_to_pseudorand(int randomno, struct pseudorand_softc *ls)$/;"	f
attach_rtclock_to_ltimer	dev/lamebus/rtclock_ltimer.c	/^attach_rtclock_to_ltimer(int rtclockno, struct ltimer_softc *ls)$/;"	f
backing_store	include/cache.h	/^  struct vnode *backing_store;$/;"	m	struct:cache	typeref:struct:cache::vnode
backsp	lib/kgets.c	/^backsp(void)$/;"	f	file:
badnames	fs/vfs/vfslist.c	/^badnames(const char *n1, const char *n2, const char *n3)$/;"	f	file:
beep	dev/generic/beep.c	/^beep(void)$/;"	f
beep_softc	dev/generic/beep.h	/^struct beep_softc {$/;"	s
bitmap	include/bitmap.h	/^struct bitmap {$/;"	s
bitmap_alloc	lib/bitmap.c	/^bitmap_alloc(struct bitmap *b, u_int32_t *index)$/;"	f
bitmap_create	lib/bitmap.c	/^bitmap_create(u_int32_t nbits)$/;"	f
bitmap_destroy	lib/bitmap.c	/^bitmap_destroy(struct bitmap *b)$/;"	f
bitmap_getdata	lib/bitmap.c	/^bitmap_getdata(struct bitmap *b)$/;"	f
bitmap_isset	lib/bitmap.c	/^bitmap_isset(struct bitmap *b, u_int32_t index) $/;"	f
bitmap_mark	lib/bitmap.c	/^bitmap_mark(struct bitmap *b, u_int32_t index)$/;"	f
bitmap_translate	lib/bitmap.c	/^bitmap_translate(u_int32_t bitno, u_int32_t *ix, WORD_TYPE *mask)$/;"	f	file:
bitmap_unmark	lib/bitmap.c	/^bitmap_unmark(struct bitmap *b, u_int32_t index)$/;"	f
bitmaptest	test/bitmaptest.c	/^bitmaptest(int nargs, char **args)$/;"	f
blocktype	lib/kheap.c	/^int blocktype(size_t sz)$/;"	f	file:
boot	main/main.c	/^boot(void)$/;"	f	file:
bootfs_lock	fs/vfs/vfslookup.c	/^static struct lock *bootfs_lock = NULL;$/;"	v	typeref:struct:lock	file:
bootfs_vnode	fs/vfs/vfslookup.c	/^static struct vnode *bootfs_vnode = NULL;$/;"	v	typeref:struct:vnode	file:
bs_beep	dev/generic/beep.h	/^	void (*bs_beep)(void *devdata);$/;"	m	struct:beep_softc
bs_devdata	dev/generic/beep.h	/^	void *bs_devdata;$/;"	m	struct:beep_softc
buf_hdr	include/cache.h	/^struct buf_hdr {$/;"	s
buffertest1	test/buffertest1.c	/^int buffertest1(int nargs, char **args)$/;"	f
buffertest2	test/buffertest2.c	/^int buffertest2(int nargs, char **args)$/;"	f
bufs	include/cache.h	/^  struct buf_hdr bufs[NBUFS];$/;"	m	struct:cache	typeref:struct:cache::buf_hdr
bus_map_area	arch/mips/include/bus.h	20;"	d
bus_read_register	arch/mips/include/bus.h	17;"	d
bus_write_register	arch/mips/include/bus.h	14;"	d
busy_cv	include/cache.h	/^  struct cv *busy_cv; \/* wait for buffer io to complete *\/$/;"	m	struct:buf_hdr	typeref:struct:buf_hdr::cv
c0_cause	arch/mips/include/asmdefs.h	57;"	d
c0_context	arch/mips/include/asmdefs.h	49;"	d
c0_entryhi	arch/mips/include/asmdefs.h	54;"	d
c0_entrylo	arch/mips/include/asmdefs.h	46;"	d
c0_epc	arch/mips/include/asmdefs.h	58;"	d
c0_index	arch/mips/include/asmdefs.h	44;"	d
c0_prid	arch/mips/include/asmdefs.h	59;"	d
c0_random	arch/mips/include/asmdefs.h	45;"	d
c0_status	arch/mips/include/asmdefs.h	56;"	d
c0_vaddr	arch/mips/include/asmdefs.h	52;"	d
c_lock	include/cache.h	/^  struct lock *c_lock;    \/* cache-wide lock to synchronize access *\/$/;"	m	struct:cache	typeref:struct:cache::lock
cache	include/cache.h	/^struct cache {$/;"	s
cache_init	cache/cache.c	/^int cache_init()$/;"	f
cache_read	cache/cache.c	/^int cache_read(int id, void *blk)$/;"	f
cache_write	cache/cache.c	/^int cache_write(int id, void *blk)$/;"	f
change_bootfs	fs/vfs/vfslookup.c	/^change_bootfs(struct vnode *newguy)$/;"	f	file:
check_cache	test/buffertest2.c	/^check_cache(void *junk, unsigned long me)$/;"	f	file:
check_cache_integrity	cache/cache.c	/^void check_cache_integrity()$/;"	f
checkfilesystem	test/fstest.c	/^checkfilesystem(int nargs, char **args)$/;"	f	file:
checksubpage	lib/kheap.c	/^checksubpage(struct pageref *pr)$/;"	f	file:
checksubpage	lib/kheap.c	203;"	d	file:
checksubpages	lib/kheap.c	/^checksubpages(void)$/;"	f	file:
checksubpages	lib/kheap.c	234;"	d	file:
clocksleep	thread/hardclock.c	/^clocksleep(int num_secs)$/;"	f
cmd_bootfs	main/menu.c	/^cmd_bootfs(int nargs, char **args)$/;"	f	file:
cmd_chdir	main/menu.c	/^cmd_chdir(int nargs, char **args)$/;"	f	file:
cmd_dbflags	main/menu.c	/^cmd_dbflags(int nargs, char **args) {$/;"	f	file:
cmd_dispatch	main/menu.c	/^cmd_dispatch(char *cmd)$/;"	f	file:
cmd_kheapstats	main/menu.c	/^cmd_kheapstats(int nargs, char **args)$/;"	f	file:
cmd_mainmenu	main/menu.c	/^cmd_mainmenu(int n, char **a)$/;"	f	file:
cmd_mount	main/menu.c	/^cmd_mount(int nargs, char **args)$/;"	f	file:
cmd_opsmenu	main/menu.c	/^cmd_opsmenu(int n, char **a)$/;"	f	file:
cmd_panic	main/menu.c	/^cmd_panic(int nargs, char **args)$/;"	f	file:
cmd_prog	main/menu.c	/^cmd_prog(int nargs, char **args)$/;"	f	file:
cmd_progthread	main/menu.c	/^cmd_progthread(void *ptr, unsigned long nargs)$/;"	f	file:
cmd_pwd	main/menu.c	/^cmd_pwd(int nargs, char **args)$/;"	f	file:
cmd_quit	main/menu.c	/^cmd_quit(int nargs, char **args)$/;"	f	file:
cmd_shell	main/menu.c	/^cmd_shell(int nargs, char **args)$/;"	f	file:
cmd_sync	main/menu.c	/^cmd_sync(int nargs, char **args)$/;"	f	file:
cmd_testmenu	main/menu.c	/^cmd_testmenu(int n, char **a)$/;"	f	file:
cmd_unmount	main/menu.c	/^cmd_unmount(int nargs, char **args)$/;"	f	file:
cmdtable	main/menu.c	/^} cmdtable[] = {$/;"	v	typeref:struct:__anon6	file:
common_exception	arch/mips/mips/exception.S	/^common_exception:	$/;"	l
common_prog	main/menu.c	/^common_prog(int nargs, char **args)$/;"	f	file:
compute_thread	test/tt3.c	/^compute_thread(void *junk1, unsigned long num)$/;"	f	file:
con_close	dev/generic/console.c	/^con_close(struct device *dev)$/;"	f	file:
con_input	dev/generic/console.c	/^con_input(void *vcs, int ch)$/;"	f
con_io	dev/generic/console.c	/^con_io(struct device *dev, struct uio *uio)$/;"	f	file:
con_ioctl	dev/generic/console.c	/^con_ioctl(struct device *dev, int op, userptr_t data)$/;"	f	file:
con_open	dev/generic/console.c	/^con_open(struct device *dev, int openflags)$/;"	f	file:
con_softc	dev/generic/console.h	/^struct con_softc {$/;"	s
con_start	dev/generic/console.c	/^con_start(void *vcs)$/;"	f
con_userlock_read	dev/generic/console.c	/^static struct lock *con_userlock_read = NULL;$/;"	v	typeref:struct:lock	file:
con_userlock_write	dev/generic/console.c	/^static struct lock *con_userlock_write = NULL;$/;"	v	typeref:struct:lock	file:
config_beep	dev/generic/beep.c	/^config_beep(struct beep_softc *bs, int unit)$/;"	f
config_con	dev/generic/console.c	/^config_con(struct con_softc *cs, int unit)$/;"	f
config_emu	dev/lamebus/emu.c	/^config_emu(struct emu_softc *sc, int emuno)$/;"	f
config_lhd	dev/lamebus/lhd.c	/^config_lhd(struct lhd_softc *lh, int lhdno)$/;"	f
config_lnet	dev/lamebus/lnet.c	/^config_lnet(struct lnet_softc *sc, int lnetno)$/;"	f
config_lrandom	dev/lamebus/lrandom.c	/^config_lrandom(struct lrandom_softc *lr, int lrandomno)$/;"	f
config_lscreen	dev/lamebus/lscreen.c	/^config_lscreen(struct lscreen_softc *sc, int lscreenno)$/;"	f
config_lser	dev/lamebus/lser.c	/^config_lser(struct lser_softc *sc, int lserno)$/;"	f
config_ltimer	dev/lamebus/ltimer.c	/^config_ltimer(struct ltimer_softc *lt, int ltimerno)$/;"	f
config_ltrace	dev/lamebus/ltrace.c	/^config_ltrace(struct ltrace_softc *sc, int ltraceno)$/;"	f
config_random	dev/generic/random.c	/^config_random(struct random_softc *rs, int unit)$/;"	f
config_rtclock	dev/generic/rtclock.c	/^config_rtclock(struct rtclock_softc *rtc, int unit)$/;"	f
cons_vnode	userprog/file_syscalls.c	/^struct vnode *cons_vnode;$/;"	v	typeref:struct:vnode
console_send	lib/kprintf.c	/^console_send(void *junk, const char *data, size_t len)$/;"	f	file:
const_userptr_t	include/types.h	/^typedef const struct __userptr *const_userptr_t;$/;"	t	typeref:struct:__userptr
copycheck	lib/copyinout.c	/^copycheck(const_userptr_t userptr, size_t len, size_t *stoplen)$/;"	f	file:
copyfail	lib/copyinout.c	/^copyfail(void)$/;"	f	file:
copyin	lib/copyinout.c	/^copyin(const_userptr_t usersrc, void *dest, size_t len)$/;"	f
copyinstr	lib/copyinout.c	/^copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *actual)$/;"	f
copyout	lib/copyinout.c	/^copyout(const void *src, userptr_t userdest, size_t len)$/;"	f
copyoutstr	lib/copyinout.c	/^copyoutstr(const char *src, userptr_t userdest, size_t len, size_t *actual)$/;"	f
copystr	lib/copyinout.c	/^copystr(char *dest, const char *src, size_t maxlen, size_t stoplen,$/;"	f	file:
count	include/synch.h	/^	volatile int count;$/;"	m	struct:semaphore
cpu_halt	arch/mips/mips/spl.c	/^cpu_halt(void)$/;"	f
cpu_idle	arch/mips/mips/spl.c	/^cpu_idle(void)$/;"	f
createstress	test/fstest.c	/^DEFTEST(createstress);$/;"	v
createstress_thread	test/fstest.c	/^createstress_thread(void *fs, unsigned long num)$/;"	f	file:
cs_devdata	dev/generic/console.h	/^	void *cs_devdata;$/;"	m	struct:con_softc
cs_gotchar	dev/generic/console.h	/^	int cs_gotchar;$/;"	m	struct:con_softc
cs_rsem	dev/generic/console.h	/^	struct semaphore *cs_rsem;$/;"	m	struct:con_softc	typeref:struct:con_softc::semaphore
cs_send	dev/generic/console.h	/^	void (*cs_send)(void *devdata, int ch);$/;"	m	struct:con_softc
cs_sendpolled	dev/generic/console.h	/^	void (*cs_sendpolled)(void *devdata, int ch);$/;"	m	struct:con_softc
cs_wsem	dev/generic/console.h	/^	struct semaphore *cs_wsem;$/;"	m	struct:con_softc	typeref:struct:con_softc::semaphore
curkstack	arch/mips/mips/pcb.c	/^u_int32_t curkstack;	\/* curthread's kernel stack, for use on kernel entry *\/$/;"	v
curspl	arch/mips/mips/spl.c	/^int curspl = SPL_HIGH;$/;"	v
curthread	thread/thread.c	/^struct thread *curthread;$/;"	v	typeref:struct:thread
cv	include/synch.h	/^struct cv {$/;"	s
cv_broadcast	thread/synch.c	/^cv_broadcast(struct cv *cv, struct lock *lock)$/;"	f
cv_create	thread/synch.c	/^cv_create(const char *name)$/;"	f
cv_destroy	thread/synch.c	/^cv_destroy(struct cv *cv)$/;"	f
cv_signal	thread/synch.c	/^cv_signal(struct cv *cv, struct lock *lock)$/;"	f
cv_wait	thread/synch.c	/^cv_wait(struct cv *cv, struct lock *lock)$/;"	f
cvtest	test/synchtest.c	/^cvtest(int nargs, char **args)$/;"	f
cvtestthread	test/synchtest.c	/^cvtestthread(void *junk, unsigned long num)$/;"	f	file:
d_blocks	include/dev.h	/^	u_int32_t d_blocks;$/;"	m	struct:device
d_blocksize	include/dev.h	/^	u_int32_t d_blocksize;$/;"	m	struct:device
d_close	include/dev.h	/^	int (*d_close)(struct device *);$/;"	m	struct:device
d_data	include/dev.h	/^	void *d_data;   \/* device-specific data *\/$/;"	m	struct:device
d_io	include/dev.h	/^	int (*d_io)(struct device *, struct uio *);$/;"	m	struct:device
d_ioctl	include/dev.h	/^	int (*d_ioctl)(struct device *, int op, userptr_t data);$/;"	m	struct:device
d_open	include/dev.h	/^	int (*d_open)(struct device *, int flags_from_open);$/;"	m	struct:device
data	include/cache.h	/^  char *data;    \/* content of buffer *\/$/;"	m	struct:buf_hdr
data	lib/queue.c	/^	void **data;$/;"	m	struct:queue	file:
dbflags	lib/kprintf.c	/^u_int32_t dbflags = 0;$/;"	v
dbflags_print	main/menu.c	/^dbflags_print() {$/;"	f	file:
delayed_outbuf	dev/generic/console.c	/^static char delayed_outbuf[DELAYBUFSIZE];$/;"	v	file:
delayed_outbuf_pos	dev/generic/console.c	/^static size_t delayed_outbuf_pos=0;$/;"	v	file:
dev_bootstrap	dev/init.c	/^dev_bootstrap(void)$/;"	f
dev_close	fs/vfs/device.c	/^dev_close(struct vnode *v)$/;"	f	file:
dev_create_vnode	fs/vfs/device.c	/^dev_create_vnode(struct device *dev)$/;"	f
dev_gettype	fs/vfs/device.c	/^dev_gettype(struct vnode *v, u_int32_t *ret)$/;"	f	file:
dev_ioctl	fs/vfs/device.c	/^dev_ioctl(struct vnode *v, int op, userptr_t data)$/;"	f	file:
dev_lookparent	fs/vfs/device.c	/^dev_lookparent(struct vnode *dir, $/;"	f	file:
dev_lookup	fs/vfs/device.c	/^dev_lookup(struct vnode *dir, $/;"	f	file:
dev_mmap	fs/vfs/device.c	/^dev_mmap(struct vnode *v  \/* add stuff as needed *\/)$/;"	f	file:
dev_namefile	fs/vfs/device.c	/^dev_namefile(struct vnode *v, struct uio *uio)$/;"	f	file:
dev_open	fs/vfs/device.c	/^dev_open(struct vnode *v, int flags)$/;"	f	file:
dev_read	fs/vfs/device.c	/^dev_read(struct vnode *v, struct uio *uio)$/;"	f	file:
dev_reclaim	fs/vfs/device.c	/^dev_reclaim(struct vnode *v)$/;"	f	file:
dev_stat	fs/vfs/device.c	/^dev_stat(struct vnode *v, struct stat *statbuf)$/;"	f	file:
dev_truncate	fs/vfs/device.c	/^dev_truncate(struct vnode *v, off_t len)$/;"	f	file:
dev_tryseek	fs/vfs/device.c	/^dev_tryseek(struct vnode *v, off_t pos)$/;"	f	file:
dev_vnode_ops	fs/vfs/device.c	/^static const struct vnode_ops dev_vnode_ops = {$/;"	v	typeref:struct:vnode_ops	file:
dev_write	fs/vfs/device.c	/^dev_write(struct vnode *v, struct uio *uio)$/;"	f	file:
device	include/dev.h	/^struct device {$/;"	s
devnull_create	fs/vfs/devnull.c	/^devnull_create(void)$/;"	f
dirty	include/cache.h	/^  int dirty;     \/* TRUE if buffer data modified since read from disk *\/$/;"	m	struct:buf_hdr
docreatestress	test/fstest.c	/^docreatestress(const char *filesys)$/;"	f	file:
dofstest	test/fstest.c	/^dofstest(const char *filesys)$/;"	f	file:
doinclude	conf/config	/^    function doinclude(file,     lineno) {$/;"	f
doing_io	include/cache.h	/^  int doing_io;  \/* TRUE if buf data is being read from or written to disk *\/$/;"	m	struct:buf_hdr
done	test/buffertest2.c	/^static volatile int done = FALSE;$/;"	v	file:
donesem	test/synchtest.c	/^static struct semaphore *donesem;$/;"	v	typeref:struct:semaphore	file:
donesem	test/tt3.c	/^static struct semaphore *donesem;$/;"	v	typeref:struct:semaphore	file:
doreadstress	test/fstest.c	/^doreadstress(const char *filesys)$/;"	f	file:
dowritestress	test/fstest.c	/^dowritestress(const char *filesys)$/;"	f	file:
dowritestress2	test/fstest.c	/^dowritestress2(const char *filesys)$/;"	f	file:
dumb_consoleIO_bootstrap	userprog/file_syscalls.c	/^void dumb_consoleIO_bootstrap() $/;"	f
dumpsubpage	lib/kheap.c	/^dumpsubpage(struct pageref *pr)$/;"	f	file:
e_busdata	dev/lamebus/emu.h	/^	void *e_busdata;$/;"	m	struct:emu_softc
e_buspos	dev/lamebus/emu.h	/^	u_int32_t e_buspos;$/;"	m	struct:emu_softc
e_ehsize	include/elf.h	/^	u_int16_t	e_ehsize;          \/* actual size of file header *\/$/;"	m	struct:__anon3
e_entry	include/elf.h	/^	u_int32_t	e_entry;           \/* address of program entry point *\/$/;"	m	struct:__anon3
e_flags	include/elf.h	/^	u_int32_t	e_flags;	   \/* ignore *\/$/;"	m	struct:__anon3
e_ident	include/elf.h	/^	unsigned char	e_ident[ELF_NIDENT];   \/* magic number et al. *\/$/;"	m	struct:__anon3
e_iobuf	dev/lamebus/emu.h	/^	void *e_iobuf;$/;"	m	struct:emu_softc
e_lock	dev/lamebus/emu.h	/^	struct lock *e_lock;$/;"	m	struct:emu_softc	typeref:struct:emu_softc::lock
e_machine	include/elf.h	/^	u_int16_t	e_machine;             \/* processor type file is for *\/$/;"	m	struct:__anon3
e_phentsize	include/elf.h	/^	u_int16_t	e_phentsize;       \/* actual size of phdr *\/$/;"	m	struct:__anon3
e_phnum	include/elf.h	/^	u_int16_t	e_phnum;           \/* number of phdrs *\/$/;"	m	struct:__anon3
e_phoff	include/elf.h	/^	u_int32_t	e_phoff;           \/* location in file of phdrs *\/$/;"	m	struct:__anon3
e_result	dev/lamebus/emu.h	/^	u_int32_t e_result;$/;"	m	struct:emu_softc
e_sem	dev/lamebus/emu.h	/^	struct semaphore *e_sem;$/;"	m	struct:emu_softc	typeref:struct:emu_softc::semaphore
e_shentsize	include/elf.h	/^	u_int16_t	e_shentsize;       \/* ignore *\/$/;"	m	struct:__anon3
e_shnum	include/elf.h	/^	u_int16_t	e_shnum;           \/* ignore *\/$/;"	m	struct:__anon3
e_shoff	include/elf.h	/^	u_int32_t	e_shoff;           \/* ignore *\/$/;"	m	struct:__anon3
e_shstrndx	include/elf.h	/^	u_int16_t	e_shstrndx;        \/* ignore *\/$/;"	m	struct:__anon3
e_type	include/elf.h	/^	u_int16_t	e_type;                \/* type of file this is *\/$/;"	m	struct:__anon3
e_unit	dev/lamebus/emu.h	/^	int e_unit;$/;"	m	struct:emu_softc
e_version	include/elf.h	/^	u_int32_t	e_version;             \/* ELF version *\/$/;"	m	struct:__anon3
ef_emu	include/emufs.h	/^	struct emu_softc *ef_emu;	\/* device *\/$/;"	m	struct:emufs_fs	typeref:struct:emufs_fs::emu_softc
ef_fs	include/emufs.h	/^	struct fs ef_fs;		\/* abstract filesystem structure *\/$/;"	m	struct:emufs_fs	typeref:struct:emufs_fs::fs
ef_root	include/emufs.h	/^	struct emufs_vnode *ef_root;	\/* root vnode *\/$/;"	m	struct:emufs_fs	typeref:struct:emufs_fs::emufs_vnode
ef_vnodes	include/emufs.h	/^	struct array *ef_vnodes;	\/* table of loaded vnodes *\/$/;"	m	struct:emufs_fs	typeref:struct:emufs_fs::array
emu_close	dev/lamebus/emu.c	/^emu_close(struct emu_softc *sc, u_int32_t handle)$/;"	f	file:
emu_doread	dev/lamebus/emu.c	/^emu_doread(struct emu_softc *sc, u_int32_t handle, u_int32_t len,$/;"	f	file:
emu_getsize	dev/lamebus/emu.c	/^emu_getsize(struct emu_softc *sc, u_int32_t handle, off_t *retval)$/;"	f	file:
emu_irq	dev/lamebus/emu.c	/^emu_irq(void *dev)$/;"	f
emu_open	dev/lamebus/emu.c	/^emu_open(struct emu_softc *sc, u_int32_t handle, const char *name,$/;"	f	file:
emu_read	dev/lamebus/emu.c	/^emu_read(struct emu_softc *sc, u_int32_t handle, u_int32_t len,$/;"	f	file:
emu_readdir	dev/lamebus/emu.c	/^emu_readdir(struct emu_softc *sc, u_int32_t handle, u_int32_t len,$/;"	f	file:
emu_rreg	dev/lamebus/emu.c	/^emu_rreg(struct emu_softc *sc, u_int32_t reg)$/;"	f	file:
emu_softc	dev/lamebus/emu.h	/^struct emu_softc {$/;"	s
emu_trunc	dev/lamebus/emu.c	/^emu_trunc(struct emu_softc *sc, u_int32_t handle, off_t len)$/;"	f	file:
emu_waitdone	dev/lamebus/emu.c	/^emu_waitdone(struct emu_softc *sc)$/;"	f	file:
emu_wreg	dev/lamebus/emu.c	/^emu_wreg(struct emu_softc *sc, u_int32_t reg, u_int32_t val)$/;"	f	file:
emu_write	dev/lamebus/emu.c	/^emu_write(struct emu_softc *sc, u_int32_t handle, u_int32_t len,$/;"	f	file:
emufs_addtovfs	dev/lamebus/emu.c	/^emufs_addtovfs(struct emu_softc *sc, const char *devname)$/;"	f	file:
emufs_close	dev/lamebus/emu.c	/^emufs_close(struct vnode *v)$/;"	f	file:
emufs_creat	dev/lamebus/emu.c	/^emufs_creat(struct vnode *dir, const char *name, int excl, struct vnode **ret)$/;"	f	file:
emufs_dir_gettype	dev/lamebus/emu.c	/^emufs_dir_gettype(struct vnode *v, u_int32_t *result)$/;"	f	file:
emufs_dirops	dev/lamebus/emu.c	/^static const struct vnode_ops emufs_dirops = {$/;"	v	typeref:struct:vnode_ops	file:
emufs_file_gettype	dev/lamebus/emu.c	/^emufs_file_gettype(struct vnode *v, u_int32_t *result)$/;"	f	file:
emufs_fileops	dev/lamebus/emu.c	/^static const struct vnode_ops emufs_fileops = {$/;"	v	typeref:struct:vnode_ops	file:
emufs_fs	include/emufs.h	/^struct emufs_fs {$/;"	s
emufs_fsync	dev/lamebus/emu.c	/^emufs_fsync(struct vnode *v)$/;"	f	file:
emufs_getdirentry	dev/lamebus/emu.c	/^emufs_getdirentry(struct vnode *v, struct uio *uio)$/;"	f	file:
emufs_getroot	dev/lamebus/emu.c	/^emufs_getroot(struct fs *fs)$/;"	f	file:
emufs_getvolname	dev/lamebus/emu.c	/^emufs_getvolname(struct fs *fs)$/;"	f	file:
emufs_ioctl	dev/lamebus/emu.c	/^emufs_ioctl(struct vnode *v, int op, userptr_t data)$/;"	f	file:
emufs_isdir	dev/lamebus/emu.c	/^emufs_isdir(void)$/;"	f	file:
emufs_loadvnode	dev/lamebus/emu.c	/^emufs_loadvnode(struct emufs_fs *ef, u_int32_t handle, int isdir,$/;"	f	file:
emufs_lookparent	dev/lamebus/emu.c	/^emufs_lookparent(struct vnode *dir, char *pathname, struct vnode **ret,$/;"	f	file:
emufs_lookup	dev/lamebus/emu.c	/^emufs_lookup(struct vnode *dir, char *pathname, struct vnode **ret)$/;"	f	file:
emufs_namefile	dev/lamebus/emu.c	/^emufs_namefile(struct vnode *v, struct uio *uio)$/;"	f	file:
emufs_notdir	dev/lamebus/emu.c	/^emufs_notdir(void)$/;"	f	file:
emufs_open	dev/lamebus/emu.c	/^emufs_open(struct vnode *v, int openflags)$/;"	f	file:
emufs_opendir	dev/lamebus/emu.c	/^emufs_opendir(struct vnode *v, int openflags)$/;"	f	file:
emufs_read	dev/lamebus/emu.c	/^emufs_read(struct vnode *v, struct uio *uio)$/;"	f	file:
emufs_reclaim	dev/lamebus/emu.c	/^emufs_reclaim(struct vnode *v)$/;"	f	file:
emufs_stat	dev/lamebus/emu.c	/^emufs_stat(struct vnode *v, struct stat *statbuf)$/;"	f	file:
emufs_sync	dev/lamebus/emu.c	/^emufs_sync(struct fs *fs)$/;"	f	file:
emufs_truncate	dev/lamebus/emu.c	/^emufs_truncate(struct vnode *v, off_t len)$/;"	f	file:
emufs_tryseek	dev/lamebus/emu.c	/^emufs_tryseek(struct vnode *v, off_t pos)$/;"	f	file:
emufs_unimp	dev/lamebus/emu.c	/^emufs_unimp(void)$/;"	f	file:
emufs_unmount	dev/lamebus/emu.c	/^emufs_unmount(struct fs *fs)$/;"	f	file:
emufs_vnode	include/emufs.h	/^struct emufs_vnode {$/;"	s
emufs_write	dev/lamebus/emu.c	/^emufs_write(struct vnode *v, struct uio *uio)$/;"	f	file:
ev_emu	include/emufs.h	/^	struct emu_softc *ev_emu;	\/* device *\/$/;"	m	struct:emufs_vnode	typeref:struct:emufs_vnode::emu_softc
ev_handle	include/emufs.h	/^	u_int32_t ev_handle;		\/* file handle *\/$/;"	m	struct:emufs_vnode
ev_v	include/emufs.h	/^	struct vnode ev_v;		\/* abstract vnode structure *\/$/;"	m	struct:emufs_vnode	typeref:struct:emufs_vnode::vnode
exception	arch/mips/mips/exception.S	/^exception:$/;"	l
exception_end	arch/mips/mips/exception.S	/^exception_end:$/;"	l
exception_return	arch/mips/mips/exception.S	/^exception_return:$/;"	l
exorcise	thread/thread.c	/^exorcise(void)$/;"	f	file:
fail	test/synchtest.c	/^fail(unsigned long num, const char *msg)$/;"	f	file:
fill_deadbeef	lib/kheap.c	/^fill_deadbeef(void *vptr, size_t len)$/;"	f	file:
findmount	fs/vfs/vfslist.c	/^findmount(const char *devname, struct knowndev **result)$/;"	f	file:
finish	test/tt3.c	/^finish(int howmanytotal)$/;"	f	file:
firstfree	arch/mips/mips/ram.c	/^u_int32_t firstfree;   \/* first free virtual address; set by start.S *\/$/;"	v
firstpaddr	arch/mips/mips/ram.c	/^static u_int32_t firstpaddr;  \/* address of first free physical page *\/$/;"	v	file:
firstpage	arch/mips/mips/dumbvm.c	/^static u_int32_t firstpage; \/* first page of interest to dumbvm *\/$/;"	v	file:
flag_name	include/lib.h	/^static const char *flag_name[] __attribute__((used)) = {$/;"	v
flush_delay_buf	dev/generic/console.c	/^flush_delay_buf(void)$/;"	f	file:
free_cache_mem	cache/cache.c	/^static void free_cache_mem(int lastalloc)$/;"	f	file:
free_kpages	arch/mips/mips/dumbvm.c	/^free_kpages(vaddr_t addr)$/;"	f
freelist	lib/kheap.c	/^struct freelist {$/;"	s	file:
freelist_offset	lib/kheap.c	/^	u_int16_t freelist_offset;$/;"	m	struct:pageref	file:
freepageref	lib/kheap.c	/^freepageref(struct pageref *p)$/;"	f	file:
freephys_map	arch/mips/mips/dumbvm.c	/^static struct bitmap freephys_map; \/* bit clear if page free, set if used *\/$/;"	v	typeref:struct:bitmap	file:
fs	include/fs.h	/^struct fs {$/;"	s
fs_data	include/fs.h	/^	void *fs_data;$/;"	m	struct:fs
fs_getroot	include/fs.h	/^	struct vnode *(*fs_getroot)(struct fs *);$/;"	m	struct:fs	typeref:struct:fs::fs_getroot
fs_getvolname	include/fs.h	/^	const char   *(*fs_getvolname)(struct fs *);$/;"	m	struct:fs
fs_sync	include/fs.h	/^	int           (*fs_sync)(struct fs *);$/;"	m	struct:fs
fs_unmount	include/fs.h	/^	int           (*fs_unmount)(struct fs *);$/;"	m	struct:fs
fstest	test/fstest.c	/^DEFTEST(fstest);$/;"	v
fstest_makename	test/fstest.c	/^fstest_makename(char *buf, size_t buflen, $/;"	f	file:
fstest_read	test/fstest.c	/^fstest_read(const char *fs, const char *namesuffix)$/;"	f	file:
fstest_remove	test/fstest.c	/^fstest_remove(const char *fs, const char *namesuffix)$/;"	f	file:
fstest_write	test/fstest.c	/^fstest_write(const char *fs, const char *namesuffix,$/;"	f	file:
func	main/menu.c	/^	int (*func)(const char *device);$/;"	m	struct:__anon5	file:
func	main/menu.c	/^	int (*func)(int nargs, char **args);$/;"	m	struct:__anon6	file:
genprobe	conf/config	/^    function genprobe(dev, devunit, bus, busunit) {$/;"	f
get_status	arch/mips/mips/spl.c	18;"	d	file:
getbase	conf/config	/^    function getbase(invalmsg, d,       base) {$/;"	f
getch	dev/generic/console.c	/^getch(void)$/;"	f
getch_intr	dev/generic/console.c	/^getch_intr(struct con_softc *cs)$/;"	f	file:
getdevice	fs/vfs/vfslookup.c	/^getdevice(char *path, char **subpath, struct vnode **startvn)$/;"	f	file:
getinterval	main/menu.c	/^getinterval(time_t s1, u_int32_t ns1, time_t s2, u_int32_t ns2,$/;"	f
getppages	arch/mips/mips/dumbvm.c	/^getppages(unsigned long npages)$/;"	f	file:
gettime	dev/generic/rtclock.c	/^gettime(time_t *secs, u_int32_t *nsecs)$/;"	f
getunit	conf/config	/^    function getunit(invalmsg, d,       u, tmp) {$/;"	f
gp	arch/mips/include/asmdefs.h	38;"	d
hardclock	thread/hardclock.c	/^hardclock(void)$/;"	f
harvard_copyright	main/main.c	/^static const char harvard_copyright[] =$/;"	v	file:
haveclock	dev/lamebus/ltimer.c	/^static int haveclock=0;$/;"	v	file:
id	include/cache.h	/^  int id;        \/* identifier == disk block # cached in this buffer *\/$/;"	m	struct:buf_hdr
in_interrupt	arch/mips/mips/interrupt.c	/^int in_interrupt;$/;"	v
inc_nextpid	thread/pid.c	/^inc_nextpid(void)$/;"	f	file:
init_sem	test/buffertest1.c	/^init_sem(void)$/;"	f	file:
init_sem	test/buffertest2.c	/^init_sem(void)$/;"	f	file:
init_sem	test/threadtest.c	/^init_sem(void)$/;"	f	file:
init_threadsem	test/fstest.c	/^init_threadsem(void)$/;"	f	file:
inititems	test/synchtest.c	/^inititems(void)$/;"	f	file:
int16_t	arch/mips/include/types.h	/^typedef short     int16_t;		\/* 16-bit signed integer *\/$/;"	t
int32_t	arch/mips/include/types.h	/^typedef int       int32_t;		\/* 32-bit signed integer *\/$/;"	t
int64_t	arch/mips/include/types.h	/^typedef long long int64_t;		\/* 64-bit signed integer *\/$/;"	t
int8_t	arch/mips/include/types.h	/^typedef char      int8_t;		\/* 8-bit signed integer *\/$/;"	t
interrupts_off	arch/mips/mips/spl.c	/^interrupts_off(void)$/;"	f	file:
interrupts_on	arch/mips/mips/spl.c	/^interrupts_on(void)$/;"	f	file:
interrupts_onoff	arch/mips/mips/spl.c	/^interrupts_onoff(void)$/;"	f	file:
intptr_t	arch/mips/include/types.h	/^typedef long intptr_t;			\/* Signed pointer-sized integer *\/$/;"	t
iov_kbase	include/uio.h	27;"	d
iov_len	include/uio.h	/^	size_t iov_len;                \/* Length of data *\/$/;"	m	struct:iovec
iov_ubase	include/uio.h	28;"	d
iov_un	include/uio.h	/^	} iov_un;$/;"	m	struct:iovec	typeref:union:iovec::__anon2
iovec	include/uio.h	/^struct iovec {$/;"	s
jmp_buf	arch/mips/include/setjmp.h	/^typedef u_int32_t jmp_buf[__JB_REGS];$/;"	t
jointest1	test/jointest.c	/^jointest1(int nargs, char **args)$/;"	f
jointest2	test/jointest.c	/^int jointest2(int nargs, char **args)$/;"	f
jointestthread	test/jointest.c	/^jointestthread(void *junk, unsigned long num)$/;"	f	file:
k0	arch/mips/include/asmdefs.h	36;"	d
k1	arch/mips/include/asmdefs.h	37;"	d
kd_device	fs/vfs/vfslist.c	/^	struct device *kd_device;$/;"	m	struct:knowndev	typeref:struct:knowndev::device	file:
kd_fs	fs/vfs/vfslist.c	/^	struct fs *kd_fs;$/;"	m	struct:knowndev	typeref:struct:knowndev::fs	file:
kd_name	fs/vfs/vfslist.c	/^	char *kd_name;$/;"	m	struct:knowndev	file:
kd_rawname	fs/vfs/vfslist.c	/^	char *kd_rawname;$/;"	m	struct:knowndev	file:
kd_vnode	fs/vfs/vfslist.c	/^	struct vnode *kd_vnode;$/;"	m	struct:knowndev	typeref:struct:knowndev::vnode	file:
kfree	lib/kheap.c	/^kfree(void *ptr)$/;"	f
kgets	lib/kgets.c	/^kgets(char *buf, size_t maxlen)$/;"	f
kheap_printstats	lib/kheap.c	/^kheap_printstats(void)$/;"	f
kill_curthread	arch/mips/mips/trap.c	/^kill_curthread(u_int32_t epc, unsigned code, u_int32_t vaddr)$/;"	f	file:
kmain	main/main.c	/^kmain(char *arguments)$/;"	f
kmalloc	lib/kheap.c	/^kmalloc(size_t sz)$/;"	f
knowndev	fs/vfs/vfslist.c	/^struct knowndev {$/;"	s	file:
knowndevs	fs/vfs/vfslist.c	/^static struct array *knowndevs;$/;"	v	typeref:struct:array	file:
knowndevs_lock	fs/vfs/vfslist.c	/^static struct lock *knowndevs_lock;$/;"	v	typeref:struct:lock	file:
kprintf	lib/kprintf.c	/^kprintf(const char *fmt, ...)$/;"	f
kprintf_bootstrap	lib/kprintf.c	/^kprintf_bootstrap(void)$/;"	f
kprintf_lock	lib/kprintf.c	/^static struct lock *kprintf_lock;$/;"	v	typeref:struct:lock	file:
kstrdup	lib/misc.c	/^kstrdup(const char *s)$/;"	f
lamebus	arch/mips/mips/lamebus_mips.c	/^static struct lamebus_softc *lamebus;$/;"	v	typeref:struct:lamebus_softc	file:
lamebus_attach_interrupt	dev/lamebus/lamebus.c	/^lamebus_attach_interrupt(struct lamebus_softc *sc, int slot,$/;"	f
lamebus_detach_interrupt	dev/lamebus/lamebus.c	/^lamebus_detach_interrupt(struct lamebus_softc *sc, int slot)$/;"	f
lamebus_init	dev/lamebus/lamebus.c	/^lamebus_init(void)$/;"	f
lamebus_interrupt	dev/lamebus/lamebus.c	/^lamebus_interrupt(struct lamebus_softc *lamebus)$/;"	f
lamebus_map_area	arch/mips/mips/lamebus_mips.c	/^lamebus_map_area(struct lamebus_softc *bus, int slot, u_int32_t offset)$/;"	f
lamebus_mark	dev/lamebus/lamebus.c	/^lamebus_mark(struct lamebus_softc *sc, int slot)$/;"	f
lamebus_poweroff	dev/lamebus/lamebus.c	/^lamebus_poweroff(struct lamebus_softc *lamebus)$/;"	f
lamebus_probe	dev/lamebus/lamebus.c	/^lamebus_probe(struct lamebus_softc *sc,$/;"	f
lamebus_ramsize	dev/lamebus/lamebus.c	/^lamebus_ramsize(void)$/;"	f
lamebus_read_register	arch/mips/mips/lamebus_mips.c	/^lamebus_read_register(struct lamebus_softc *bus, int slot, u_int32_t offset)$/;"	f
lamebus_softc	dev/lamebus/lamebus.h	/^struct lamebus_softc {$/;"	s
lamebus_unmark	dev/lamebus/lamebus.c	/^lamebus_unmark(struct lamebus_softc *sc, int slot)$/;"	f
lamebus_write_register	arch/mips/mips/lamebus_mips.c	/^lamebus_write_register(struct lamebus_softc *bus, int slot,$/;"	f
lastpaddr	arch/mips/mips/ram.c	/^static u_int32_t lastpaddr;   \/* one past end of last free physical page *\/$/;"	v	file:
lastpage	arch/mips/mips/dumbvm.c	/^static u_int32_t lastpage;  \/* last page of interest to dumbvm *\/$/;"	v	file:
lb_irqfunc	dev/lamebus/lamebus.h	/^typedef void (*lb_irqfunc)(void *devdata);$/;"	t
lbolt	thread/hardclock.c	/^int lbolt;$/;"	v
lbolt_counter	thread/hardclock.c	/^static int lbolt_counter;$/;"	v	file:
lh_buf	dev/lamebus/lhd.h	/^	void *lh_buf;			\/* Pointer to on-card I\/O buffer *\/$/;"	m	struct:lhd_softc
lh_busdata	dev/lamebus/lhd.h	/^	void *lh_busdata;		\/* The bus we're on *\/ $/;"	m	struct:lhd_softc
lh_buspos	dev/lamebus/lhd.h	/^	u_int32_t lh_buspos;		\/* Our slot on that bus *\/$/;"	m	struct:lhd_softc
lh_clear	dev/lamebus/lhd.h	/^	struct semaphore *lh_clear;	\/* Synchronization *\/$/;"	m	struct:lhd_softc	typeref:struct:lhd_softc::semaphore
lh_dev	dev/lamebus/lhd.h	/^	struct device lh_dev;		\/* VFS device structure *\/$/;"	m	struct:lhd_softc	typeref:struct:lhd_softc::device
lh_done	dev/lamebus/lhd.h	/^	struct semaphore *lh_done;$/;"	m	struct:lhd_softc	typeref:struct:lhd_softc::semaphore
lh_result	dev/lamebus/lhd.h	/^	int lh_result;			\/* Result from I\/O operation *\/$/;"	m	struct:lhd_softc
lh_unit	dev/lamebus/lhd.h	/^	int lh_unit;			\/* What number lhd we are *\/$/;"	m	struct:lhd_softc
lhd_close	dev/lamebus/lhd.c	/^lhd_close(struct device *d)$/;"	f	file:
lhd_code_to_errno	dev/lamebus/lhd.c	/^int lhd_code_to_errno(struct lhd_softc *lh, int code)$/;"	f	file:
lhd_io	dev/lamebus/lhd.c	/^lhd_io(struct device *d, struct uio *uio)$/;"	f	file:
lhd_ioctl	dev/lamebus/lhd.c	/^lhd_ioctl(struct device *d, int op, userptr_t data)$/;"	f	file:
lhd_iodone	dev/lamebus/lhd.c	/^lhd_iodone(struct lhd_softc *lh, int err)$/;"	f	file:
lhd_irq	dev/lamebus/lhd.c	/^lhd_irq(void *vlh)$/;"	f
lhd_open	dev/lamebus/lhd.c	/^lhd_open(struct device *d, int openflags)$/;"	f	file:
lhd_rdreg	dev/lamebus/lhd.c	/^u_int32_t lhd_rdreg(struct lhd_softc *lh, u_int32_t reg)$/;"	f	file:
lhd_softc	dev/lamebus/lhd.h	/^struct lhd_softc {$/;"	s
lhd_wreg	dev/lamebus/lhd.c	/^void lhd_wreg(struct lhd_softc *lh, u_int32_t reg, u_int32_t val)$/;"	f	file:
load_elf	userprog/loadelf.c	/^load_elf(struct vnode *v, vaddr_t *entrypoint)$/;"	f
load_segment	userprog/loadelf.c	/^load_segment(struct vnode *v, off_t offset, vaddr_t vaddr, $/;"	f	file:
lock	include/synch.h	/^struct lock {$/;"	s
lock_acquire	thread/synch.c	/^lock_acquire(struct lock *lock)$/;"	f
lock_create	thread/synch.c	/^lock_create(const char *name)$/;"	f
lock_destroy	thread/synch.c	/^lock_destroy(struct lock *lock)$/;"	f
lock_do_i_hold	thread/synch.c	/^lock_do_i_hold(struct lock *lock)$/;"	f
lock_release	thread/synch.c	/^lock_release(struct lock *lock)$/;"	f
locktest	test/synchtest.c	/^locktest(int nargs, char **args)$/;"	f
locktestthread	test/synchtest.c	/^locktestthread(void *junk, unsigned long num)$/;"	f	file:
loudthread	test/threadtest.c	/^loudthread(void *junk, unsigned long num)$/;"	f	file:
lr_bus	dev/lamebus/lrandom.h	/^	void *lr_bus;$/;"	m	struct:lrandom_softc
lr_buspos	dev/lamebus/lrandom.h	/^	u_int32_t lr_buspos;$/;"	m	struct:lrandom_softc
lrandom_randmax	dev/lamebus/lrandom.c	/^lrandom_randmax(void *devdata)$/;"	f
lrandom_random	dev/lamebus/lrandom.c	/^lrandom_random(void *devdata)$/;"	f
lrandom_read	dev/lamebus/lrandom.c	/^lrandom_read(void *devdata, struct uio *uio)$/;"	f
lrandom_softc	dev/lamebus/lrandom.h	/^struct lrandom_softc {$/;"	s
ls_busdata	dev/lamebus/lscreen.h	/^	void *ls_busdata;		\/\/ bus we're on$/;"	m	struct:lscreen_softc
ls_busdata	dev/lamebus/lser.h	/^	void *ls_busdata;$/;"	m	struct:lser_softc
ls_buspos	dev/lamebus/lscreen.h	/^	u_int32_t ls_buspos;		\/\/ position on that bus$/;"	m	struct:lscreen_softc
ls_buspos	dev/lamebus/lser.h	/^	u_int32_t ls_buspos;$/;"	m	struct:lser_softc
ls_cx	dev/lamebus/lscreen.h	/^	unsigned ls_cx, ls_cy;        \/\/ cursor position$/;"	m	struct:lscreen_softc
ls_cy	dev/lamebus/lscreen.h	/^	unsigned ls_cx, ls_cy;        \/\/ cursor position$/;"	m	struct:lscreen_softc
ls_devdata	dev/lamebus/lamebus.h	/^	void        *ls_devdata[LB_NSLOTS];$/;"	m	struct:lamebus_softc
ls_devdata	dev/lamebus/lscreen.h	/^	void *ls_devdata;			\/\/ data and functions for$/;"	m	struct:lscreen_softc
ls_devdata	dev/lamebus/lser.h	/^	void *ls_devdata;$/;"	m	struct:lser_softc
ls_height	dev/lamebus/lscreen.h	/^	unsigned ls_width, ls_height; \/\/ screen size$/;"	m	struct:lscreen_softc
ls_input	dev/lamebus/lscreen.h	/^	void (*ls_input)(void *devdata, int ch); \/\/ console)$/;"	m	struct:lscreen_softc
ls_input	dev/lamebus/lser.h	/^	void (*ls_input)(void *devdata, int ch);$/;"	m	struct:lser_softc
ls_irqfuncs	dev/lamebus/lamebus.h	/^	lb_irqfunc   ls_irqfuncs[LB_NSLOTS];$/;"	m	struct:lamebus_softc
ls_screen	dev/lamebus/lscreen.h	/^	char *ls_screen;              \/\/ memory-mapped screen buffer$/;"	m	struct:lscreen_softc
ls_slotsinuse	dev/lamebus/lamebus.h	/^	u_int32_t    ls_slotsinuse;$/;"	m	struct:lamebus_softc
ls_start	dev/lamebus/lscreen.h	/^	void (*ls_start)(void *devdata);	\/\/ upper device (perhaps$/;"	m	struct:lscreen_softc
ls_start	dev/lamebus/lser.h	/^	void (*ls_start)(void *devdata);$/;"	m	struct:lser_softc
ls_wbusy	dev/lamebus/lser.h	/^	volatile int ls_wbusy;     \/* true if write in progress *\/$/;"	m	struct:lser_softc
ls_width	dev/lamebus/lscreen.h	/^	unsigned ls_width, ls_height; \/\/ screen size$/;"	m	struct:lscreen_softc
lscreen_char	dev/lamebus/lscreen.c	/^lscreen_char(struct lscreen_softc *sc, int ch)$/;"	f	file:
lscreen_irq	dev/lamebus/lscreen.c	/^lscreen_irq(void *vsc)$/;"	f
lscreen_newline	dev/lamebus/lscreen.c	/^lscreen_newline(struct lscreen_softc *sc)$/;"	f	file:
lscreen_softc	dev/lamebus/lscreen.h	/^struct lscreen_softc {$/;"	s
lscreen_write	dev/lamebus/lscreen.c	/^lscreen_write(void *vsc, int ch)$/;"	f
lser_irq	dev/lamebus/lser.c	/^lser_irq(void *vsc)$/;"	f
lser_softc	dev/lamebus/lser.h	/^struct lser_softc {$/;"	s
lser_spin_until_write	dev/lamebus/lser.c	/^lser_spin_until_write(struct lser_softc *sc)$/;"	f	file:
lser_write	dev/lamebus/lser.c	/^lser_write(void *vls, int ch)$/;"	f
lser_writepolled	dev/lamebus/lser.c	/^lser_writepolled(void *vsc, int ch)$/;"	f
lt_bus	dev/lamebus/ltimer.h	/^	void *lt_bus;		\/* bus we're on *\/$/;"	m	struct:ltimer_softc
lt_busdata	dev/lamebus/ltrace.h	/^	void *lt_busdata;$/;"	m	struct:ltrace_softc
lt_buspos	dev/lamebus/ltimer.h	/^	u_int32_t lt_buspos;	\/* position (slot) on that bus *\/$/;"	m	struct:ltimer_softc
lt_buspos	dev/lamebus/ltrace.h	/^	u_int32_t lt_buspos;$/;"	m	struct:ltrace_softc
lt_hardclock	dev/lamebus/ltimer.h	/^	int lt_hardclock;        \/* true if we should call hardclock() *\/$/;"	m	struct:ltimer_softc
ltimer_beep	dev/lamebus/ltimer.c	/^ltimer_beep(void *vlt)$/;"	f
ltimer_gettime	dev/lamebus/ltimer.c	/^ltimer_gettime(void *vlt, time_t *secs, u_int32_t *nsecs)$/;"	f
ltimer_irq	dev/lamebus/ltimer.c	/^ltimer_irq(void *vlt)$/;"	f
ltimer_softc	dev/lamebus/ltimer.h	/^struct ltimer_softc {$/;"	s
ltrace_debug	dev/lamebus/ltrace.c	/^ltrace_debug(u_int32_t code)$/;"	f
ltrace_dump	dev/lamebus/ltrace.c	/^ltrace_dump(u_int32_t code)$/;"	f
ltrace_off	dev/lamebus/ltrace.c	/^ltrace_off(u_int32_t code)$/;"	f
ltrace_on	dev/lamebus/ltrace.c	/^ltrace_on(u_int32_t code)$/;"	f
ltrace_softc	dev/lamebus/ltrace.h	/^struct ltrace_softc {$/;"	s
machdep_dev_bootstrap	arch/mips/mips/lamebus_mips.c	/^machdep_dev_bootstrap(void)$/;"	f
mainmenu	main/menu.c	/^static const char *mainmenu[] = {$/;"	v	file:
make_computes	test/tt3.c	/^make_computes(int howmany)$/;"	f	file:
make_runnable	thread/scheduler.c	/^make_runnable(struct thread *t)$/;"	f
make_sleepalots	test/tt3.c	/^make_sleepalots(int howmany)$/;"	f	file:
mallocstress	test/malloctest.c	/^mallocstress(int nargs, char **args)$/;"	f
malloctest	test/malloctest.c	/^malloctest(int nargs, char **args)$/;"	f
mallocthread	test/malloctest.c	/^mallocthread(void *sm, unsigned long num)$/;"	f	file:
max	lib/array.c	/^	int max;$/;"	m	struct:array	file:
max_block_id	cache/cache.c	/^int max_block_id;$/;"	v
md_forkentry	arch/mips/mips/syscall.c	/^md_forkentry(struct trapframe *tf)$/;"	f
md_halt	arch/mips/mips/lamebus_mips.c	/^md_halt(void)$/;"	f
md_initpcb	arch/mips/mips/pcb.c	/^md_initpcb(struct pcb *pcb, char *stack, $/;"	f
md_initpcb0	arch/mips/mips/pcb.c	/^md_initpcb0(struct pcb *pcb)$/;"	f
md_panic	arch/mips/mips/lamebus_mips.c	/^md_panic(void)$/;"	f
md_poweroff	arch/mips/mips/lamebus_mips.c	/^md_poweroff(void)$/;"	f
md_reboot	arch/mips/mips/lamebus_mips.c	/^md_reboot(void)$/;"	f
md_switch	arch/mips/mips/pcb.c	/^md_switch(struct pcb *old, struct pcb *nu)$/;"	f
md_usermode	arch/mips/mips/trap.c	/^md_usermode(int argc, userptr_t argv, vaddr_t stack, vaddr_t entry)$/;"	f
menu	main/menu.c	/^menu(char *args)$/;"	f
menu_execute	main/menu.c	/^menu_execute(char *line, int isargs)$/;"	f	file:
mergexy	dev/lamebus/lscreen.c	/^mergexy(unsigned x, unsigned y)$/;"	f	file:
mi_switch	thread/thread.c	/^mi_switch(threadstate_t nextstate)$/;"	f	file:
mi_threadstart	thread/thread.c	/^mi_threadstart(void *data1, unsigned long data2, $/;"	f
mips_flushicache	arch/mips/mips/cache_mips1.S	/^mips_flushicache:$/;"	l
mips_interrupt	arch/mips/mips/interrupt.c	/^mips_interrupt(u_int32_t cause)$/;"	f
mips_lamebus_interrupt	arch/mips/mips/lamebus_mips.c	/^mips_lamebus_interrupt(void)$/;"	f
mips_ramsize	arch/mips/mips/lamebus_mips.c	/^mips_ramsize(void)$/;"	f
mips_switch	arch/mips/mips/switch.S	/^mips_switch:$/;"	l
mips_syscall	arch/mips/mips/syscall.c	/^mips_syscall(struct trapframe *tf)$/;"	f
mips_threadstart	arch/mips/mips/threadstart.S	/^mips_threadstart:$/;"	l
mips_trap	arch/mips/mips/trap.c	/^mips_trap(struct trapframe *tf)$/;"	f
mips_usermode	arch/mips/mips/trap.c	/^mips_usermode(struct trapframe *tf)$/;"	f
mk_kuio	userprog/uio.c	/^mk_kuio(struct uio *uio, void *kbuf, size_t len, off_t pos, enum uio_rw rw)$/;"	f
mk_useruio	userprog/file_syscalls.c	/^mk_useruio(struct uio *u, userptr_t buf, size_t len, off_t offset, $/;"	f	file:
mkrawname	fs/vfs/vfslist.c	/^mkrawname(const char *name)$/;"	f	file:
mounttable	main/menu.c	/^} mounttable[] = {$/;"	v	typeref:struct:__anon5	file:
name	include/synch.h	/^	char *name;$/;"	m	struct:cv
name	include/synch.h	/^	char *name;$/;"	m	struct:lock
name	include/synch.h	/^	char *name;$/;"	m	struct:semaphore
name	main/menu.c	/^	const char *name;$/;"	m	struct:__anon5	file:
name	main/menu.c	/^	const char *name;$/;"	m	struct:__anon6	file:
nbits	include/bitmap.h	/^        u_int32_t nbits;$/;"	m	struct:bitmap
nettest	test/nettest.c	/^nettest(void)$/;"	f
next	lib/kheap.c	/^	struct freelist *next;$/;"	m	struct:freelist	typeref:struct:freelist::freelist	file:
next_all	lib/kheap.c	/^	struct pageref *next_all;$/;"	m	struct:pageref	typeref:struct:pageref::pageref	file:
next_idx	include/cache.h	/^  int next_idx;$/;"	m	struct:cache
next_samesize	lib/kheap.c	/^	struct pageref *next_samesize;$/;"	m	struct:pageref	typeref:struct:pageref::pageref	file:
nextpid	thread/pid.c	/^static pid_t nextpid;			\/\/ next candidate pid$/;"	v	file:
nextread	lib/queue.c	/^	int nextread;	\/\/ next element to read from (was tail)$/;"	m	struct:queue	file:
nextwrite	lib/queue.c	/^	int nextwrite;	\/\/ next element to write to (was head)$/;"	m	struct:queue	file:
nfree	lib/kheap.c	/^	u_int16_t nfree;$/;"	m	struct:pageref	file:
nprocs	thread/pid.c	/^static int nprocs;			\/\/ number of allocated pids$/;"	v	file:
null_creat	fs/vfs/device.c	/^null_creat(struct vnode *v, const char *name, int excl, struct vnode **result)$/;"	f	file:
null_fsync	fs/vfs/device.c	/^null_fsync(struct vnode *v)$/;"	f	file:
null_io	fs/vfs/device.c	/^null_io(struct vnode *v, struct uio *uio)$/;"	f	file:
null_link	fs/vfs/device.c	/^null_link(struct vnode *v, const char *name, struct vnode *file)$/;"	f	file:
null_nameop	fs/vfs/device.c	/^null_nameop(struct vnode *v, const char *name)$/;"	f	file:
null_rename	fs/vfs/device.c	/^null_rename(struct vnode *v, const char *n1, struct vnode *v2, const char *n2)$/;"	f	file:
null_symlink	fs/vfs/device.c	/^null_symlink(struct vnode *v, const char *contents, const char *name)$/;"	f	file:
nullclose	fs/vfs/devnull.c	/^nullclose(struct device *dev)$/;"	f	file:
nullio	fs/vfs/devnull.c	/^nullio(struct device *dev, struct uio *uio)$/;"	f	file:
nullioctl	fs/vfs/devnull.c	/^nullioctl(struct device *dev, int op, userptr_t data)$/;"	f	file:
nullopen	fs/vfs/devnull.c	/^nullopen(struct device *dev, int openflags)$/;"	f	file:
num	lib/array.c	/^	int num;$/;"	m	struct:array	file:
numthreads	thread/thread.c	/^static int numthreads;$/;"	v	file:
off_t	include/kern/types.h	/^typedef int32_t off_t;   \/* Offset within file *\/$/;"	t
opsmenu	main/menu.c	/^static const char *opsmenu[] = {$/;"	v	file:
owner	include/synch.h	/^        struct thread * volatile owner;$/;"	m	struct:lock
p_align	include/elf.h	/^	u_int32_t	p_align;     \/* Required alignment - can ignore *\/$/;"	m	struct:__anon4
p_filesz	include/elf.h	/^	u_int32_t	p_filesz;    \/* Size of data within file *\/$/;"	m	struct:__anon4
p_flags	include/elf.h	/^	u_int32_t	p_flags;     \/* Flags *\/$/;"	m	struct:__anon4
p_memsz	include/elf.h	/^	u_int32_t	p_memsz;     \/* Size of data to be loaded into memory*\/$/;"	m	struct:__anon4
p_offset	include/elf.h	/^	u_int32_t	p_offset;    \/* Location of data within file *\/$/;"	m	struct:__anon4
p_paddr	include/elf.h	/^	u_int32_t	p_paddr;     \/* Ignore *\/$/;"	m	struct:__anon4
p_type	include/elf.h	/^	u_int32_t	p_type;      \/* Type of segment *\/$/;"	m	struct:__anon4
p_vaddr	include/elf.h	/^	u_int32_t	p_vaddr;     \/* Virtual address *\/$/;"	m	struct:__anon4
paddr_t	arch/mips/include/ktypes.h	/^typedef u_int32_t paddr_t;   \/* type for a physical address *\/$/;"	t
pageaddr_and_blocktype	lib/kheap.c	/^	vaddr_t pageaddr_and_blocktype;$/;"	m	struct:pageref	file:
pageref	lib/kheap.c	/^struct pageref {$/;"	s	file:
pagerefs	lib/kheap.c	/^static struct pageref pagerefs[NPAGEREFS];$/;"	v	typeref:struct:pageref	file:
pagerefs_inuse	lib/kheap.c	/^static u_int32_t pagerefs_inuse[INUSE_WORDS];$/;"	v	file:
panic	lib/kprintf.c	/^panic(const char *fmt, ...)$/;"	f
panicstr	arch/mips/mips/start.S	/^panicstr:$/;"	l
pcb	arch/mips/include/pcb.h	/^struct pcb {$/;"	s
pcb_badfaultfunc	arch/mips/include/pcb.h	/^	pcb_faultfunc pcb_badfaultfunc; \/\/ recovery for fatal kernel traps$/;"	m	struct:pcb
pcb_copyjmp	arch/mips/include/pcb.h	/^	jmp_buf pcb_copyjmp;            \/\/ jump area used by copyin\/out etc.$/;"	m	struct:pcb
pcb_faultfunc	arch/mips/include/pcb.h	/^typedef void (*pcb_faultfunc)(void);$/;"	t
pcb_ininterrupt	arch/mips/include/pcb.h	/^	u_int32_t pcb_ininterrupt;  \/\/ are we in an interrupt handler?$/;"	m	struct:pcb
pcb_kstack	arch/mips/include/pcb.h	/^	u_int32_t pcb_kstack;	    \/\/ stack to load on entry to kernel$/;"	m	struct:pcb
pcb_switchstack	arch/mips/include/pcb.h	/^	u_int32_t pcb_switchstack;  \/\/ stack saved during context switch$/;"	m	struct:pcb
pi_drop	thread/pid.c	/^pi_drop(pid_t pid)$/;"	f	file:
pi_exited	thread/pid.c	/^	volatile int pi_exited;		\/\/ true if thread has exited$/;"	m	struct:pidinfo	file:
pi_exitstatus	thread/pid.c	/^	int pi_exitstatus;		\/\/ status (only valid if exited)$/;"	m	struct:pidinfo	file:
pi_get	thread/pid.c	/^pi_get(pid_t pid)$/;"	f	file:
pi_joinable	thread/pid.c	/^        int pi_joinable;                \/\/ true if thread is joinable$/;"	m	struct:pidinfo	file:
pi_pid	thread/pid.c	/^	int pi_pid;			\/\/ process id of this thread$/;"	m	struct:pidinfo	file:
pi_ppid	thread/pid.c	/^	int pi_ppid;			\/\/ process id of parent thread$/;"	m	struct:pidinfo	file:
pi_put	thread/pid.c	/^pi_put(pid_t pid, struct pidinfo *pi)$/;"	f	file:
pid_alloc	thread/pid.c	/^pid_alloc(pid_t *retval)$/;"	f
pid_bootstrap	thread/pid.c	/^pid_bootstrap(void)$/;"	f
pid_t	include/kern/types.h	/^typedef int32_t pid_t;   \/* Process ID *\/$/;"	t
pid_unalloc	thread/pid.c	/^pid_unalloc(pid_t theirpid)$/;"	f
pidinfo	thread/pid.c	/^static struct pidinfo *pidinfo[PROCS_MAX]; \/\/ actual pid info$/;"	v	typeref:struct:pidinfo	file:
pidinfo	thread/pid.c	/^struct pidinfo {$/;"	s	file:
pidinfo_create	thread/pid.c	/^pidinfo_create(pid_t pid, pid_t ppid)$/;"	f	file:
pidinfo_destroy	thread/pid.c	/^pidinfo_destroy(struct pidinfo *pi)$/;"	f	file:
print_run_queue	thread/scheduler.c	/^print_run_queue(void)$/;"	f
printfile	test/fstest.c	/^printfile(int nargs, char **args)$/;"	f
processline	conf/config	/^    function processline(filename, lineno) {$/;"	f
ps_seed	dev/generic/pseudorand.h	/^	u_int32_t ps_seed;$/;"	m	struct:pseudorand_softc
pseudoattach_pseudorand	dev/generic/pseudorand.c	/^pseudoattach_pseudorand(int unit)$/;"	f
pseudorand_randmax	dev/generic/pseudorand.c	/^pseudorand_randmax(void *devdata)$/;"	f
pseudorand_random	dev/generic/pseudorand.c	/^pseudorand_random(void *devdata)$/;"	f
pseudorand_read	dev/generic/pseudorand.c	/^pseudorand_read(void *devdata, struct uio *uio)$/;"	f
pseudorand_softc	dev/generic/pseudorand.h	/^struct pseudorand_softc {$/;"	s
putch	dev/generic/console.c	/^putch(int ch)$/;"	f
putch_delayed	dev/generic/console.c	/^putch_delayed(int ch)$/;"	f	file:
putch_intr	dev/generic/console.c	/^putch_intr(struct con_softc *cs, int ch)$/;"	f	file:
putch_polled	dev/generic/console.c	/^putch_polled(struct con_softc *cs, int ch)$/;"	f	file:
q_addtail	lib/queue.c	/^q_addtail(struct queue *q, void *ptr)$/;"	f
q_create	lib/queue.c	/^q_create(int size)$/;"	f
q_destroy	lib/queue.c	/^q_destroy(struct queue *q)$/;"	f
q_empty	lib/queue.c	/^q_empty(struct queue *q)$/;"	f
q_getend	lib/queue.c	/^q_getend(struct queue *q)$/;"	f
q_getguy	lib/queue.c	/^q_getguy(struct queue *q, int index)$/;"	f
q_getsize	lib/queue.c	/^q_getsize(struct queue *q)$/;"	f
q_getstart	lib/queue.c	/^q_getstart(struct queue *q)$/;"	f
q_grow	lib/queue.c	/^q_grow(struct queue *q, int targetsize)$/;"	f	file:
q_preallocate	lib/queue.c	/^q_preallocate(struct queue *q, int size)$/;"	f
q_remhead	lib/queue.c	/^q_remhead(struct queue *q)$/;"	f
queue	lib/queue.c	/^struct queue {$/;"	s	file:
queuetest	test/queuetest.c	/^queuetest(int nargs, char **args)$/;"	f
quietthread	test/threadtest.c	/^quietthread(void *junk, unsigned long num)$/;"	f	file:
ra	arch/mips/include/asmdefs.h	41;"	d
ram_bootstrap	arch/mips/mips/ram.c	/^ram_bootstrap(void)$/;"	f
ram_getsize	arch/mips/mips/ram.c	/^ram_getsize(u_int32_t *lo, u_int32_t *hi)$/;"	f
ram_stealmem	arch/mips/mips/ram.c	/^ram_stealmem(unsigned long npages)$/;"	f
randclose	dev/generic/random.c	/^randclose(struct device *dev)$/;"	f	file:
randio	dev/generic/random.c	/^randio(struct device *dev, struct uio *uio)$/;"	f	file:
randioctl	dev/generic/random.c	/^randioctl(struct device *dev, int op, userptr_t data)$/;"	f	file:
randmax	dev/generic/random.c	/^randmax(void)$/;"	f
random	dev/generic/random.c	/^random(void)$/;"	f
random_softc	dev/generic/random.h	/^struct random_softc {$/;"	s
randopen	dev/generic/random.c	/^randopen(struct device *dev, int openflags)$/;"	f	file:
read_cfg_register	dev/lamebus/lamebus.c	/^read_cfg_register(struct lamebus_softc *lb, int slot, u_int32_t offset)$/;"	f	file:
read_ctl_register	dev/lamebus/lamebus.c	/^read_ctl_register(struct lamebus_softc *lb, u_int32_t offset)$/;"	f	file:
read_in_block	cache/cache.c	/^read_in_block(int id, void *data)$/;"	f	file:
read_same_blocks	test/buffertest2.c	/^read_same_blocks(void *junk, unsigned long me)$/;"	f	file:
readstress	test/fstest.c	/^DEFTEST(readstress);$/;"	v
readstress_thread	test/fstest.c	/^readstress_thread(void *fs, unsigned long num)$/;"	f	file:
remove_lists	lib/kheap.c	/^remove_lists(struct pageref *pr, int blktype)$/;"	f	file:
replacing_id	include/cache.h	/^  int replacing_id;   \/* Id of block that will replace current one *\/$/;"	m	struct:buf_hdr
reserved	include/kern/sfs.h	/^	u_int32_t reserved[118];$/;"	m	struct:sfs_super
rotate	test/fstest.c	/^rotate(char *str, int amt)$/;"	f	file:
rs_dev	dev/generic/random.h	/^	struct device rs_dev;$/;"	m	struct:random_softc	typeref:struct:random_softc::device
rs_devdata	dev/generic/random.h	/^	void *rs_devdata;$/;"	m	struct:random_softc
rs_randmax	dev/generic/random.h	/^	u_int32_t (*rs_randmax)(void *devdata);$/;"	m	struct:random_softc
rs_random	dev/generic/random.h	/^	u_int32_t (*rs_random)(void *devdata);$/;"	m	struct:random_softc
rs_read	dev/generic/random.h	/^	int (*rs_read)(void *devdata, struct uio *uio);$/;"	m	struct:random_softc
rtc_devdata	dev/generic/rtclock.h	/^	void *rtc_devdata;$/;"	m	struct:rtclock_softc
rtc_gettime	dev/generic/rtclock.h	/^	void (*rtc_gettime)(void *devdata, time_t *secs, u_int32_t *nsecs);$/;"	m	struct:rtclock_softc
rtclock_softc	dev/generic/rtclock.h	/^struct rtclock_softc {$/;"	s
runprogram	userprog/runprogram.c	/^runprogram(char *progname)$/;"	f
runqueue	thread/scheduler.c	/^static struct queue *runqueue;$/;"	v	typeref:struct:queue	file:
runtest3	test/tt3.c	/^runtest3(int nsleeps, int ncomputes)$/;"	f	file:
runthreads	test/buffertest1.c	/^runthreads(int nthreads)$/;"	f	file:
runthreads	test/buffertest2.c	/^runthreads(int nthreads)$/;"	f	file:
runthreads	test/threadtest.c	/^runthreads(int doloud)$/;"	f	file:
s0	arch/mips/include/asmdefs.h	26;"	d
s1	arch/mips/include/asmdefs.h	27;"	d
s2	arch/mips/include/asmdefs.h	28;"	d
s3	arch/mips/include/asmdefs.h	29;"	d
s4	arch/mips/include/asmdefs.h	30;"	d
s5	arch/mips/include/asmdefs.h	31;"	d
s6	arch/mips/include/asmdefs.h	32;"	d
s7	arch/mips/include/asmdefs.h	33;"	d
s8	arch/mips/include/asmdefs.h	40;"	d
samestring	fs/vfs/vfslist.c	/^samestring(const char *a, const char *b)$/;"	f	file:
samestring3	fs/vfs/vfslist.c	/^samestring3(const char *a, const char *b, const char *c, const char *d)$/;"	f	file:
scheduler	thread/scheduler.c	/^scheduler(void)$/;"	f
scheduler_bootstrap	thread/scheduler.c	/^scheduler_bootstrap(void)$/;"	f
scheduler_killall	thread/scheduler.c	/^scheduler_killall(void)$/;"	f
scheduler_preallocate	thread/scheduler.c	/^scheduler_preallocate(int nthreads)$/;"	f
scheduler_shutdown	thread/scheduler.c	/^scheduler_shutdown(void)$/;"	f
sem_create	thread/synch.c	/^sem_create(const char *namearg, int initial_count)$/;"	f
sem_destroy	thread/synch.c	/^sem_destroy(struct semaphore *sem)$/;"	f
semaphore	include/synch.h	/^struct semaphore {$/;"	s
semtest	test/synchtest.c	/^semtest(int nargs, char **args)$/;"	f
semtestthread	test/synchtest.c	/^semtestthread(void *junk, unsigned long num)$/;"	f	file:
set_status	arch/mips/mips/spl.c	19;"	d	file:
setarch	conf/config	/^    function setarch(fn, lineno, newarch) {$/;"	f
setup	test/tt3.c	/^setup(void)$/;"	f	file:
sf_gp	arch/mips/include/switchframe.h	/^	u_int32_t sf_gp;$/;"	m	struct:switchframe
sf_ra	arch/mips/include/switchframe.h	/^	u_int32_t sf_ra;$/;"	m	struct:switchframe
sf_s0	arch/mips/include/switchframe.h	/^	u_int32_t sf_s0;$/;"	m	struct:switchframe
sf_s1	arch/mips/include/switchframe.h	/^	u_int32_t sf_s1;$/;"	m	struct:switchframe
sf_s2	arch/mips/include/switchframe.h	/^	u_int32_t sf_s2;$/;"	m	struct:switchframe
sf_s3	arch/mips/include/switchframe.h	/^	u_int32_t sf_s3;$/;"	m	struct:switchframe
sf_s4	arch/mips/include/switchframe.h	/^	u_int32_t sf_s4;$/;"	m	struct:switchframe
sf_s5	arch/mips/include/switchframe.h	/^	u_int32_t sf_s5;$/;"	m	struct:switchframe
sf_s6	arch/mips/include/switchframe.h	/^	u_int32_t sf_s6;$/;"	m	struct:switchframe
sf_s7	arch/mips/include/switchframe.h	/^	u_int32_t sf_s7;$/;"	m	struct:switchframe
sf_s8	arch/mips/include/switchframe.h	/^	u_int32_t sf_s8;$/;"	m	struct:switchframe
sfd_ino	include/kern/sfs.h	/^	u_int32_t sfd_ino;              \/* Inode number *\/$/;"	m	struct:sfs_dir
sfd_name	include/kern/sfs.h	/^	char sfd_name[SFS_NAMELEN];  \/* Filename *\/$/;"	m	struct:sfs_dir
sfi_direct	include/kern/sfs.h	/^	u_int32_t sfi_direct[SFS_NDIRECT];	\/* Direct blocks *\/$/;"	m	struct:sfs_inode
sfi_indirect	include/kern/sfs.h	/^	u_int32_t sfi_indirect;			\/* Indirect block *\/$/;"	m	struct:sfs_inode
sfi_linkcount	include/kern/sfs.h	/^	u_int16_t sfi_linkcount;   \/* Number of hard links to this file *\/$/;"	m	struct:sfs_inode
sfi_size	include/kern/sfs.h	/^	u_int32_t sfi_size;        \/* Size of this file (bytes) *\/$/;"	m	struct:sfs_inode
sfi_type	include/kern/sfs.h	/^	u_int16_t sfi_type;        \/* One of SFS_TYPE_* above *\/$/;"	m	struct:sfs_inode
sfi_waste	include/kern/sfs.h	/^	u_int32_t sfi_waste[128-3-SFS_NDIRECT]; \/* unused space *\/$/;"	m	struct:sfs_inode
sfs_absfs	include/sfs.h	/^	struct fs sfs_absfs;            \/* abstract filesystem structure *\/$/;"	m	struct:sfs_fs	typeref:struct:sfs_fs::fs
sfs_balloc	fs/sfs/sfs_vnode.c	/^sfs_balloc(struct sfs_fs *sfs, u_int32_t *diskblock)$/;"	f	file:
sfs_bfree	fs/sfs/sfs_vnode.c	/^sfs_bfree(struct sfs_fs *sfs, u_int32_t diskblock)$/;"	f	file:
sfs_blockio	fs/sfs/sfs_vnode.c	/^sfs_blockio(struct sfs_vnode *sv, struct uio *uio)$/;"	f	file:
sfs_bmap	fs/sfs/sfs_vnode.c	/^sfs_bmap(struct sfs_vnode *sv, u_int32_t fileblock, int doalloc,$/;"	f	file:
sfs_bused	fs/sfs/sfs_vnode.c	/^sfs_bused(struct sfs_fs *sfs, u_int32_t diskblock)$/;"	f	file:
sfs_clearblock	fs/sfs/sfs_vnode.c	/^sfs_clearblock(struct sfs_fs *sfs, u_int32_t block)$/;"	f	file:
sfs_close	fs/sfs/sfs_vnode.c	/^sfs_close(struct vnode *v)$/;"	f	file:
sfs_creat	fs/sfs/sfs_vnode.c	/^sfs_creat(struct vnode *v, const char *name, int excl, struct vnode **ret)$/;"	f	file:
sfs_device	include/sfs.h	/^	struct device *sfs_device;      \/* device mounted on *\/$/;"	m	struct:sfs_fs	typeref:struct:sfs_fs::device
sfs_dir	include/kern/sfs.h	/^struct sfs_dir {$/;"	s
sfs_dir_findname	fs/sfs/sfs_vnode.c	/^sfs_dir_findname(struct sfs_vnode *sv, const char *name,$/;"	f	file:
sfs_dir_link	fs/sfs/sfs_vnode.c	/^sfs_dir_link(struct sfs_vnode *sv, const char *name, u_int32_t ino, int *slot)$/;"	f	file:
sfs_dir_nentries	fs/sfs/sfs_vnode.c	/^sfs_dir_nentries(struct sfs_vnode *sv)$/;"	f	file:
sfs_dir_unlink	fs/sfs/sfs_vnode.c	/^sfs_dir_unlink(struct sfs_vnode *sv, int slot)$/;"	f	file:
sfs_dirops	fs/sfs/sfs_vnode.c	/^static const struct vnode_ops sfs_dirops = {$/;"	v	typeref:struct:vnode_ops	file:
sfs_domount	fs/sfs/sfs_fs.c	/^sfs_domount(void *options, struct device *dev, struct fs **ret)$/;"	f	file:
sfs_fileops	fs/sfs/sfs_vnode.c	/^static const struct vnode_ops sfs_fileops = {$/;"	v	typeref:struct:vnode_ops	file:
sfs_freemap	include/sfs.h	/^	struct bitmap *sfs_freemap;     \/* blocks in use are marked 1 *\/$/;"	m	struct:sfs_fs	typeref:struct:sfs_fs::bitmap
sfs_freemapdirty	include/sfs.h	/^	int sfs_freemapdirty;           \/* true if freemap modified *\/$/;"	m	struct:sfs_fs
sfs_fs	include/sfs.h	/^struct sfs_fs {$/;"	s
sfs_fsync	fs/sfs/sfs_vnode.c	/^sfs_fsync(struct vnode *v)$/;"	f	file:
sfs_getroot	fs/sfs/sfs_vnode.c	/^sfs_getroot(struct fs *fs)$/;"	f
sfs_gettype	fs/sfs/sfs_vnode.c	/^sfs_gettype(struct vnode *v, u_int32_t *ret)$/;"	f	file:
sfs_getvolname	fs/sfs/sfs_fs.c	/^sfs_getvolname(struct fs *fs)$/;"	f	file:
sfs_inode	include/kern/sfs.h	/^struct sfs_inode {$/;"	s
sfs_io	fs/sfs/sfs_vnode.c	/^sfs_io(struct sfs_vnode *sv, struct uio *uio)$/;"	f	file:
sfs_ioctl	fs/sfs/sfs_vnode.c	/^sfs_ioctl(struct vnode *v, int op, userptr_t data)$/;"	f	file:
sfs_isdir	fs/sfs/sfs_vnode.c	/^sfs_isdir(void)$/;"	f	file:
sfs_link	fs/sfs/sfs_vnode.c	/^sfs_link(struct vnode *dir, const char *name, struct vnode *file)$/;"	f	file:
sfs_loadvnode	fs/sfs/sfs_vnode.c	/^sfs_loadvnode(struct sfs_fs *sfs, u_int32_t ino, int forcetype,$/;"	f	file:
sfs_lookonce	fs/sfs/sfs_vnode.c	/^sfs_lookonce(struct sfs_vnode *sv, const char *name, $/;"	f	file:
sfs_lookparent	fs/sfs/sfs_vnode.c	/^sfs_lookparent(struct vnode *v, char *path, struct vnode **ret,$/;"	f	file:
sfs_lookup	fs/sfs/sfs_vnode.c	/^sfs_lookup(struct vnode *v, char *path, struct vnode **ret)$/;"	f	file:
sfs_makeobj	fs/sfs/sfs_vnode.c	/^sfs_makeobj(struct sfs_fs *sfs, int type, struct sfs_vnode **ret)$/;"	f	file:
sfs_mapio	fs/sfs/sfs_fs.c	/^sfs_mapio(struct sfs_fs *sfs, enum uio_rw rw)$/;"	f	file:
sfs_mmap	fs/sfs/sfs_vnode.c	/^sfs_mmap(struct vnode *v   \/* add stuff as needed *\/)$/;"	f	file:
sfs_mount	fs/sfs/sfs_fs.c	/^sfs_mount(const char *device)$/;"	f
sfs_namefile	fs/sfs/sfs_vnode.c	/^sfs_namefile(struct vnode *vv, struct uio *uio)$/;"	f	file:
sfs_notdir	fs/sfs/sfs_vnode.c	/^sfs_notdir(void)$/;"	f	file:
sfs_open	fs/sfs/sfs_vnode.c	/^sfs_open(struct vnode *v, int openflags)$/;"	f	file:
sfs_opendir	fs/sfs/sfs_vnode.c	/^sfs_opendir(struct vnode *v, int openflags)$/;"	f	file:
sfs_partialio	fs/sfs/sfs_vnode.c	/^sfs_partialio(struct sfs_vnode *sv, struct uio *uio,$/;"	f	file:
sfs_rblock	fs/sfs/sfs_io.c	/^sfs_rblock(struct sfs_fs *sfs, void *data, u_int32_t block)$/;"	f
sfs_read	fs/sfs/sfs_vnode.c	/^sfs_read(struct vnode *v, struct uio *uio)$/;"	f	file:
sfs_readdir	fs/sfs/sfs_vnode.c	/^sfs_readdir(struct sfs_vnode *sv, struct sfs_dir *sd, int slot)$/;"	f	file:
sfs_reclaim	fs/sfs/sfs_vnode.c	/^sfs_reclaim(struct vnode *v)$/;"	f	file:
sfs_remove	fs/sfs/sfs_vnode.c	/^sfs_remove(struct vnode *dir, const char *name)$/;"	f	file:
sfs_rename	fs/sfs/sfs_vnode.c	/^sfs_rename(struct vnode *d1, const char *n1, $/;"	f	file:
sfs_rwblock	fs/sfs/sfs_io.c	/^sfs_rwblock(struct sfs_fs *sfs, struct uio *uio)$/;"	f
sfs_stat	fs/sfs/sfs_vnode.c	/^sfs_stat(struct vnode *v, struct stat *statbuf)$/;"	f	file:
sfs_super	include/kern/sfs.h	/^struct sfs_super {$/;"	s
sfs_super	include/sfs.h	/^	struct sfs_super sfs_super;	\/* on-disk superblock *\/$/;"	m	struct:sfs_fs	typeref:struct:sfs_fs::sfs_super
sfs_superdirty	include/sfs.h	/^	int sfs_superdirty;             \/* true if superblock modified *\/$/;"	m	struct:sfs_fs
sfs_sync	fs/sfs/sfs_fs.c	/^sfs_sync(struct fs *fs)$/;"	f	file:
sfs_sync_inode	fs/sfs/sfs_vnode.c	/^sfs_sync_inode(struct sfs_vnode *sv)$/;"	f	file:
sfs_truncate	fs/sfs/sfs_vnode.c	/^sfs_truncate(struct vnode *v, off_t len)$/;"	f	file:
sfs_tryseek	fs/sfs/sfs_vnode.c	/^sfs_tryseek(struct vnode *v, off_t pos)$/;"	f	file:
sfs_unimp	fs/sfs/sfs_vnode.c	/^sfs_unimp(void)$/;"	f	file:
sfs_unmount	fs/sfs/sfs_fs.c	/^sfs_unmount(struct fs *fs)$/;"	f	file:
sfs_vnode	include/sfs.h	/^struct sfs_vnode {$/;"	s
sfs_vnodes	include/sfs.h	/^	struct array *sfs_vnodes;       \/* vnodes loaded into memory *\/$/;"	m	struct:sfs_fs	typeref:struct:sfs_fs::array
sfs_wblock	fs/sfs/sfs_io.c	/^sfs_wblock(struct sfs_fs *sfs, void *data, u_int32_t block)$/;"	f
sfs_write	fs/sfs/sfs_vnode.c	/^sfs_write(struct vnode *v, struct uio *uio)$/;"	f	file:
sfs_writedir	fs/sfs/sfs_vnode.c	/^sfs_writedir(struct sfs_vnode *sv, struct sfs_dir *sd, int slot)$/;"	f	file:
showmenu	main/menu.c	/^showmenu(const char *name, const char *x[])$/;"	f	file:
shutdown	main/main.c	/^shutdown(void)$/;"	f	file:
size	lib/queue.c	/^	int size;$/;"	m	struct:queue	file:
size_t	arch/mips/include/types.h	/^typedef unsigned long size_t;		\/* Size of a memory region *\/$/;"	t
size_t	arch/mips/include/types.h	/^typedef unsigned size_t;		\/* Size of a memory region *\/$/;"	t
sizebases	lib/kheap.c	/^static struct pageref *sizebases[NSIZES];$/;"	v	typeref:struct:pageref	file:
sizes	lib/kheap.c	/^static const size_t sizes[NSIZES] = { 16, 32, 64, 128, 256, 512, 1024, 2048 };$/;"	v	file:
sleepalot_thread	test/tt3.c	/^sleepalot_thread(void *junk, unsigned long num)$/;"	f	file:
sleepers	thread/thread.c	/^static struct array *sleepers;$/;"	v	typeref:struct:array	file:
sp	arch/mips/include/asmdefs.h	39;"	d
sp_magic	include/kern/sfs.h	/^	u_int32_t sp_magic;       \/* Magic number, should be SFS_MAGIC *\/$/;"	m	struct:sfs_super
sp_nblocks	include/kern/sfs.h	/^	u_int32_t sp_nblocks;     \/* Number of blocks in fs *\/$/;"	m	struct:sfs_super
sp_volname	include/kern/sfs.h	/^	char sp_volname[SFS_VOLNAME_SIZE];  \/* Name of this volume *\/$/;"	m	struct:sfs_super
spl0	arch/mips/mips/spl.c	/^spl0(void)$/;"	f
splhigh	arch/mips/mips/spl.c	/^splhigh(void)$/;"	f
splitxy	dev/lamebus/lscreen.c	/^splitxy(u_int32_t xy, unsigned *x, unsigned *y)$/;"	f	file:
splx	arch/mips/mips/spl.c	/^splx(int newspl)$/;"	f
st_blocks	include/kern/stat.h	/^	u_int32_t st_blocks;	\/* number of blocks file is using *\/$/;"	m	struct:stat
st_mode	include/kern/stat.h	/^	u_int32_t st_mode;	\/* protection mode and file type *\/$/;"	m	struct:stat
st_nlink	include/kern/stat.h	/^	u_int32_t st_nlink;	\/* number of hard links *\/$/;"	m	struct:stat
st_size	include/kern/stat.h	/^	off_t st_size;		\/* file size (bytes) *\/$/;"	m	struct:stat
stat	include/kern/stat.h	/^struct stat {$/;"	s
strerror	lib/misc.c	/^strerror(int errcode)$/;"	f
subpage_kfree	lib/kheap.c	/^subpage_kfree(void *ptr)$/;"	f	file:
subpage_kmalloc	lib/kheap.c	/^subpage_kmalloc(size_t sz)$/;"	f	file:
sv_dirty	include/sfs.h	/^	int sv_dirty;                   \/* true if sv_i modified *\/$/;"	m	struct:sfs_vnode
sv_i	include/sfs.h	/^	struct sfs_inode sv_i;		\/* on-disk inode *\/$/;"	m	struct:sfs_vnode	typeref:struct:sfs_vnode::sfs_inode
sv_ino	include/sfs.h	/^	u_int32_t sv_ino;               \/* inode number *\/$/;"	m	struct:sfs_vnode
sv_v	include/sfs.h	/^	struct vnode sv_v;              \/* abstract vnode structure *\/$/;"	m	struct:sfs_vnode	typeref:struct:sfs_vnode::vnode
switchframe	arch/mips/include/switchframe.h	/^struct switchframe {$/;"	s
sys_errlist	include/kern/errmsg.h	/^const char *const sys_errlist[] = {$/;"	v
sys_exit	userprog/simple_syscalls.c	/^int sys_exit(int exitcode) {$/;"	f
sys_nerr	include/kern/errmsg.h	/^const int sys_nerr = sizeof(sys_errlist)\/sizeof(const char *);$/;"	v
sys_printchar	userprog/simple_syscalls.c	/^int sys_printchar(char c, int *retval) {$/;"	f
sys_read	userprog/file_syscalls.c	/^sys_read(int fd, userptr_t buf, size_t size, int *retval)$/;"	f
sys_reboot	main/main.c	/^sys_reboot(int code)$/;"	f
sys_write	userprog/file_syscalls.c	/^sys_write(int fd, userptr_t buf, size_t size, int *retval)$/;"	f
t0	arch/mips/include/asmdefs.h	18;"	d
t1	arch/mips/include/asmdefs.h	19;"	d
t2	arch/mips/include/asmdefs.h	20;"	d
t3	arch/mips/include/asmdefs.h	21;"	d
t4	arch/mips/include/asmdefs.h	22;"	d
t5	arch/mips/include/asmdefs.h	23;"	d
t6	arch/mips/include/asmdefs.h	24;"	d
t7	arch/mips/include/asmdefs.h	25;"	d
t8	arch/mips/include/asmdefs.h	34;"	d
t9	arch/mips/include/asmdefs.h	35;"	d
t_cwd	include/thread.h	/^	struct vnode *t_cwd;$/;"	m	struct:thread	typeref:struct:thread::vnode
t_name	include/thread.h	/^	char *t_name;$/;"	m	struct:thread
t_pcb	include/thread.h	/^	struct pcb t_pcb;$/;"	m	struct:thread	typeref:struct:thread::pcb
t_pid	include/thread.h	/^        pid_t t_pid; \/\/ DEMKE: ASST1$/;"	m	struct:thread
t_sleepaddr	include/thread.h	/^	const void *t_sleepaddr;$/;"	m	struct:thread
t_stack	include/thread.h	/^	char *t_stack;$/;"	m	struct:thread
t_vmspace	include/thread.h	/^	struct addrspace *t_vmspace;$/;"	m	struct:thread	typeref:struct:thread::addrspace
testa	test/arraytest.c	/^testa(struct array *a)$/;"	f	file:
testcv	test/synchtest.c	/^static struct cv *testcv;$/;"	v	typeref:struct:cv	file:
testlock	test/synchtest.c	/^static struct lock *testlock;$/;"	v	typeref:struct:lock	file:
testmenu	main/menu.c	/^static const char *testmenu[] = {$/;"	v	file:
testq	test/queuetest.c	/^testq(struct queue *q, int n)$/;"	f	file:
testsem	test/synchtest.c	/^static struct semaphore *testsem;$/;"	v	typeref:struct:semaphore	file:
testval1	test/synchtest.c	/^static volatile unsigned long testval1;$/;"	v	file:
testval2	test/synchtest.c	/^static volatile unsigned long testval2;$/;"	v	file:
testval3	test/synchtest.c	/^static volatile unsigned long testval3;$/;"	v	file:
tf_a0	arch/mips/include/trapframe.h	/^	u_int32_t tf_a0;$/;"	m	struct:trapframe
tf_a1	arch/mips/include/trapframe.h	/^	u_int32_t tf_a1;$/;"	m	struct:trapframe
tf_a2	arch/mips/include/trapframe.h	/^	u_int32_t tf_a2;$/;"	m	struct:trapframe
tf_a3	arch/mips/include/trapframe.h	/^	u_int32_t tf_a3;$/;"	m	struct:trapframe
tf_at	arch/mips/include/trapframe.h	/^	u_int32_t tf_at;	\/* Saved register 1 (AT) *\/$/;"	m	struct:trapframe
tf_cause	arch/mips/include/trapframe.h	/^	u_int32_t tf_cause;	\/* coprocessor 0 cause register *\/$/;"	m	struct:trapframe
tf_epc	arch/mips/include/trapframe.h	/^	u_int32_t tf_epc;	\/* coprocessor 0 epc register *\/$/;"	m	struct:trapframe
tf_gp	arch/mips/include/trapframe.h	/^	u_int32_t tf_gp;$/;"	m	struct:trapframe
tf_hi	arch/mips/include/trapframe.h	/^	u_int32_t tf_hi;$/;"	m	struct:trapframe
tf_k0	arch/mips/include/trapframe.h	/^	u_int32_t tf_k0;	\/* dummy (see exception.S comments) *\/$/;"	m	struct:trapframe
tf_k1	arch/mips/include/trapframe.h	/^	u_int32_t tf_k1;	\/* dummy *\/$/;"	m	struct:trapframe
tf_lo	arch/mips/include/trapframe.h	/^	u_int32_t tf_lo;$/;"	m	struct:trapframe
tf_ra	arch/mips/include/trapframe.h	/^	u_int32_t tf_ra;	\/* Saved register 31 *\/$/;"	m	struct:trapframe
tf_s0	arch/mips/include/trapframe.h	/^	u_int32_t tf_s0;$/;"	m	struct:trapframe
tf_s1	arch/mips/include/trapframe.h	/^	u_int32_t tf_s1;$/;"	m	struct:trapframe
tf_s2	arch/mips/include/trapframe.h	/^	u_int32_t tf_s2;$/;"	m	struct:trapframe
tf_s3	arch/mips/include/trapframe.h	/^	u_int32_t tf_s3;$/;"	m	struct:trapframe
tf_s4	arch/mips/include/trapframe.h	/^	u_int32_t tf_s4;$/;"	m	struct:trapframe
tf_s5	arch/mips/include/trapframe.h	/^	u_int32_t tf_s5;$/;"	m	struct:trapframe
tf_s6	arch/mips/include/trapframe.h	/^	u_int32_t tf_s6;$/;"	m	struct:trapframe
tf_s7	arch/mips/include/trapframe.h	/^	u_int32_t tf_s7;$/;"	m	struct:trapframe
tf_s8	arch/mips/include/trapframe.h	/^	u_int32_t tf_s8;$/;"	m	struct:trapframe
tf_sp	arch/mips/include/trapframe.h	/^	u_int32_t tf_sp;$/;"	m	struct:trapframe
tf_status	arch/mips/include/trapframe.h	/^	u_int32_t tf_status;	\/* coprocessor 0 status register *\/$/;"	m	struct:trapframe
tf_t0	arch/mips/include/trapframe.h	/^	u_int32_t tf_t0;$/;"	m	struct:trapframe
tf_t1	arch/mips/include/trapframe.h	/^	u_int32_t tf_t1;$/;"	m	struct:trapframe
tf_t2	arch/mips/include/trapframe.h	/^	u_int32_t tf_t2;$/;"	m	struct:trapframe
tf_t3	arch/mips/include/trapframe.h	/^	u_int32_t tf_t3;$/;"	m	struct:trapframe
tf_t4	arch/mips/include/trapframe.h	/^	u_int32_t tf_t4;$/;"	m	struct:trapframe
tf_t5	arch/mips/include/trapframe.h	/^	u_int32_t tf_t5;$/;"	m	struct:trapframe
tf_t6	arch/mips/include/trapframe.h	/^	u_int32_t tf_t6;$/;"	m	struct:trapframe
tf_t7	arch/mips/include/trapframe.h	/^	u_int32_t tf_t7;$/;"	m	struct:trapframe
tf_t8	arch/mips/include/trapframe.h	/^	u_int32_t tf_t8;$/;"	m	struct:trapframe
tf_t9	arch/mips/include/trapframe.h	/^	u_int32_t tf_t9;$/;"	m	struct:trapframe
tf_v0	arch/mips/include/trapframe.h	/^	u_int32_t tf_v0;	\/* Saved register 2 (v0) *\/$/;"	m	struct:trapframe
tf_v1	arch/mips/include/trapframe.h	/^	u_int32_t tf_v1;	\/* etc. *\/$/;"	m	struct:trapframe
tf_vaddr	arch/mips/include/trapframe.h	/^	u_int32_t tf_vaddr;	\/* coprocessor 0 vaddr register *\/$/;"	m	struct:trapframe
the_beep	dev/generic/beep.c	/^static struct beep_softc *the_beep = NULL;$/;"	v	typeref:struct:beep_softc	file:
the_cache	cache/cache.c	/^struct cache *the_cache;$/;"	v	typeref:struct:cache
the_clock	dev/generic/rtclock.c	/^static struct rtclock_softc *the_clock = NULL;$/;"	v	typeref:struct:rtclock_softc	file:
the_console	dev/generic/console.c	/^static struct con_softc *the_console = NULL;$/;"	v	typeref:struct:con_softc	file:
the_random	dev/generic/random.c	/^static struct random_softc *the_random = NULL;$/;"	v	typeref:struct:random_softc	file:
the_trace	dev/lamebus/ltrace.c	/^static struct ltrace_softc *the_trace;$/;"	v	typeref:struct:ltrace_softc	file:
thread	include/thread.h	/^struct thread {$/;"	s
thread_bootstrap	thread/thread.c	/^thread_bootstrap(void)$/;"	f
thread_create	thread/thread.c	/^thread_create(const char *name)$/;"	f	file:
thread_destroy	thread/thread.c	/^thread_destroy(struct thread *thread)$/;"	f	file:
thread_detach	thread/thread.c	/^int thread_detach(pid_t pid) {$/;"	f
thread_exit	thread/thread.c	/^thread_exit(int exitcode) \/* exitcode added for A0 *\/$/;"	f
thread_fork	thread/thread.c	/^thread_fork(const char *name, $/;"	f
thread_hassleepers	thread/thread.c	/^thread_hassleepers(const void *addr)$/;"	f
thread_join	thread/thread.c	/^int thread_join(pid_t pid, int *status) {$/;"	f
thread_killall	thread/thread.c	/^thread_killall(void)$/;"	f	file:
thread_panic	thread/thread.c	/^thread_panic(void)$/;"	f
thread_shutdown	thread/thread.c	/^thread_shutdown(void)$/;"	f
thread_sleep	thread/thread.c	/^thread_sleep(const void *addr)$/;"	f
thread_wakeone	thread/thread.c	/^thread_wakeone(const void *addr)$/;"	f
thread_wakeup	thread/thread.c	/^thread_wakeup(const void *addr)$/;"	f
thread_yield	thread/thread.c	/^thread_yield(void)$/;"	f
threadsem	test/fstest.c	/^static struct semaphore *threadsem = NULL;$/;"	v	typeref:struct:semaphore	file:
threadstate_t	thread/thread.c	/^} threadstate_t;$/;"	t	typeref:enum:__anon1	file:
threadtest	test/threadtest.c	/^threadtest(int nargs, char **args)$/;"	f
threadtest2	test/threadtest.c	/^threadtest2(int nargs, char **args)$/;"	f
threadtest3	test/tt3.c	/^threadtest3(int nargs, char **args)$/;"	f
time_t	include/kern/types.h	/^typedef int32_t time_t;  \/* Time in seconds *\/$/;"	t
translate_err	dev/lamebus/emu.c	/^translate_err(struct emu_softc *sc, u_int32_t code)$/;"	f	file:
trapcodenames	arch/mips/mips/trap.c	/^static const char *const trapcodenames[NTRAPCODES] = {$/;"	v	file:
trapframe	arch/mips/include/trapframe.h	/^struct trapframe {$/;"	s
tryattach	conf/config	/^    function tryattach(combo) {$/;"	f
tsem	test/buffertest1.c	/^static struct semaphore *tsem = NULL;$/;"	v	typeref:struct:semaphore	file:
tsem	test/buffertest2.c	/^static struct semaphore *tsem = NULL;$/;"	v	typeref:struct:semaphore	file:
tsem	test/threadtest.c	/^static struct semaphore *tsem = NULL;$/;"	v	typeref:struct:semaphore	file:
u_int16_t	arch/mips/include/types.h	/^typedef unsigned short     u_int16_t;	\/* 16-bit unsigned integer *\/$/;"	t
u_int32_t	arch/mips/include/types.h	/^typedef unsigned int       u_int32_t;	\/* 32-bit unsigned integer *\/$/;"	t
u_int64_t	arch/mips/include/types.h	/^typedef unsigned long long u_int64_t;	\/* 64-bit unsigned integer *\/$/;"	t
u_int8_t	arch/mips/include/types.h	/^typedef unsigned char      u_int8_t;	\/* 8-bit unsigned integer *\/$/;"	t
uintptr_t	arch/mips/include/types.h	/^typedef unsigned long uintptr_t;	\/* Unsigned pointer-sized integer *\/$/;"	t
uio	include/uio.h	/^struct uio {$/;"	s
uio_iovec	include/uio.h	/^	struct iovec      uio_iovec;       \/* Data block *\/$/;"	m	struct:uio	typeref:struct:uio::iovec
uio_offset	include/uio.h	/^	off_t             uio_offset;      \/* desired offset into object *\/$/;"	m	struct:uio
uio_resid	include/uio.h	/^	size_t            uio_resid;       \/* Remaining amt of data to xfer *\/$/;"	m	struct:uio
uio_rw	include/uio.h	/^	enum uio_rw       uio_rw;          \/* whether op is a read or write *\/$/;"	m	struct:uio	typeref:enum:uio::uio_rw
uio_rw	include/uio.h	/^enum uio_rw {$/;"	g
uio_seg	include/uio.h	/^enum uio_seg {$/;"	g
uio_segflg	include/uio.h	/^	enum uio_seg      uio_segflg;      \/* what kind of pointer we have *\/$/;"	m	struct:uio	typeref:enum:uio::uio_seg
uio_space	include/uio.h	/^	struct addrspace *uio_space;       \/* address space for user pointer *\/$/;"	m	struct:uio	typeref:struct:uio::addrspace
uiomove	userprog/uio.c	/^uiomove(void *ptr, size_t n, struct uio *uio)$/;"	f
uiomovezeros	userprog/uio.c	/^uiomovezeros(size_t n, struct uio *uio)$/;"	f
un_kbase	include/uio.h	/^		void      *un_kbase;   \/* kernel address (UIO_SYSSPACE) *\/$/;"	m	union:iovec::__anon2
un_ubase	include/uio.h	/^		userptr_t  un_ubase;   \/* user address (UIO_USER{,I}SPACE *\/$/;"	m	union:iovec::__anon2
update_same_blocks	test/buffertest2.c	/^update_same_blocks(void *junk, unsigned long me)$/;"	f	file:
use_blocks	test/buffertest1.c	/^use_blocks(void *junk, unsigned long me)$/;"	f	file:
userptr_t	include/types.h	/^typedef struct __userptr *userptr_t;$/;"	t	typeref:struct:__userptr
utlb_exception	arch/mips/mips/exception.S	/^utlb_exception:$/;"	l
utlb_exception_end	arch/mips/mips/exception.S	/^utlb_exception_end:$/;"	l
v	include/bitmap.h	/^        WORD_TYPE *v;$/;"	m	struct:bitmap
v	lib/array.c	/^	void **v;$/;"	m	struct:array	file:
v0	arch/mips/include/asmdefs.h	12;"	d
v1	arch/mips/include/asmdefs.h	13;"	d
va_arg	include/stdarg.h	17;"	d
va_copy	include/stdarg.h	18;"	d
va_end	include/stdarg.h	19;"	d
va_list	include/stdarg.h	/^typedef __va_list va_list;$/;"	t
va_start	include/stdarg.h	16;"	d
vaddr_t	arch/mips/include/ktypes.h	/^typedef u_int32_t vaddr_t;   \/* type for a virtual address *\/$/;"	t
vfs_adddev	fs/vfs/vfslist.c	/^vfs_adddev(const char *devname, struct device *dev, int mountable)$/;"	f
vfs_addfs	fs/vfs/vfslist.c	/^vfs_addfs(const char *devname, struct fs *fs)$/;"	f
vfs_bootstrap	fs/vfs/vfslist.c	/^vfs_bootstrap(void)$/;"	f
vfs_chdir	fs/vfs/vfscwd.c	/^vfs_chdir(char *path)$/;"	f
vfs_clearbootfs	fs/vfs/vfslookup.c	/^vfs_clearbootfs(void)$/;"	f
vfs_clearcurdir	fs/vfs/vfscwd.c	/^vfs_clearcurdir(void)$/;"	f
vfs_close	fs/vfs/vfspath.c	/^vfs_close(struct vnode *vn)$/;"	f
vfs_doadd	fs/vfs/vfslist.c	/^vfs_doadd(const char *dname, int mountable, struct device *dev, struct fs *fs)$/;"	f	file:
vfs_getcurdir	fs/vfs/vfscwd.c	/^vfs_getcurdir(struct vnode **ret)$/;"	f
vfs_getcwd	fs/vfs/vfscwd.c	/^vfs_getcwd(struct uio *uio)$/;"	f
vfs_getdevname	fs/vfs/vfslist.c	/^vfs_getdevname(struct fs *fs)$/;"	f
vfs_getroot	fs/vfs/vfslist.c	/^vfs_getroot(const char *devname, struct vnode **result)$/;"	f
vfs_initbootfs	fs/vfs/vfslookup.c	/^vfs_initbootfs(void)$/;"	f
vfs_link	fs/vfs/vfspath.c	/^vfs_link(char *oldpath, char *newpath)$/;"	f
vfs_lookparent	fs/vfs/vfslookup.c	/^vfs_lookparent(char *path, struct vnode **retval,$/;"	f
vfs_lookup	fs/vfs/vfslookup.c	/^vfs_lookup(char *path, struct vnode **retval)$/;"	f
vfs_mkdir	fs/vfs/vfspath.c	/^vfs_mkdir(char *path)$/;"	f
vfs_mount	fs/vfs/vfslist.c	/^vfs_mount(const char *devname, void *data,$/;"	f
vfs_open	fs/vfs/vfspath.c	/^vfs_open(char *path, int openflags, struct vnode **ret)$/;"	f
vfs_readlink	fs/vfs/vfspath.c	/^vfs_readlink(char *path, struct uio *uio)$/;"	f
vfs_remove	fs/vfs/vfspath.c	/^vfs_remove(char *path)$/;"	f
vfs_rename	fs/vfs/vfspath.c	/^vfs_rename(char *oldpath, char *newpath)$/;"	f
vfs_rmdir	fs/vfs/vfspath.c	/^vfs_rmdir(char *path)$/;"	f
vfs_setbootfs	fs/vfs/vfslookup.c	/^vfs_setbootfs(const char *fsname)$/;"	f
vfs_setcurdir	fs/vfs/vfscwd.c	/^vfs_setcurdir(struct vnode *dir)$/;"	f
vfs_symlink	fs/vfs/vfspath.c	/^vfs_symlink(const char *contents, char *path)$/;"	f
vfs_sync	fs/vfs/vfslist.c	/^vfs_sync(void)$/;"	f
vfs_unmount	fs/vfs/vfslist.c	/^vfs_unmount(const char *devname)$/;"	f
vfs_unmountall	fs/vfs/vfslist.c	/^vfs_unmountall(void)$/;"	f
vm_bootstrap	arch/mips/mips/dumbvm.c	/^vm_bootstrap(void)$/;"	f
vm_fault	arch/mips/mips/dumbvm.c	/^vm_fault(int faulttype, vaddr_t faultaddress)$/;"	f
vn_countlock	include/vnode.h	/^	struct lock *vn_countlock;      \/* Lock for vn_refcount\/opencount *\/$/;"	m	struct:vnode	typeref:struct:vnode::lock
vn_data	include/vnode.h	/^	void *vn_data;                  \/* Filesystem-specific data *\/$/;"	m	struct:vnode
vn_fs	include/vnode.h	/^	struct fs *vn_fs;               \/* Filesystem vnode belongs to *\/$/;"	m	struct:vnode	typeref:struct:vnode::fs
vn_opencount	include/vnode.h	/^	int vn_opencount;$/;"	m	struct:vnode
vn_ops	include/vnode.h	/^	const struct vnode_ops *vn_ops; \/* Functions on this vnode *\/$/;"	m	struct:vnode	typeref:struct:vnode::vnode_ops
vn_refcount	include/vnode.h	/^	int vn_refcount;                \/* Reference count *\/$/;"	m	struct:vnode
vnode	include/vnode.h	/^struct vnode {$/;"	s
vnode_check	fs/vfs/vnode.c	/^vnode_check(struct vnode *v, const char *opstr)$/;"	f
vnode_decopen	fs/vfs/vnode.c	/^vnode_decopen(struct vnode *vn)$/;"	f
vnode_decref	fs/vfs/vnode.c	/^vnode_decref(struct vnode *vn)$/;"	f
vnode_incopen	fs/vfs/vnode.c	/^vnode_incopen(struct vnode *vn)$/;"	f
vnode_incref	fs/vfs/vnode.c	/^vnode_incref(struct vnode *vn)$/;"	f
vnode_init	fs/vfs/vnode.c	/^vnode_init(struct vnode *vn, const struct vnode_ops *ops,$/;"	f
vnode_kill	fs/vfs/vnode.c	/^vnode_kill(struct vnode *vn)$/;"	f
vnode_ops	include/vnode.h	/^struct vnode_ops {$/;"	s
vop_close	include/vnode.h	/^	int (*vop_close)(struct vnode *object);$/;"	m	struct:vnode_ops
vop_creat	include/vnode.h	/^	int (*vop_creat)(struct vnode *dir, $/;"	m	struct:vnode_ops
vop_fsync	include/vnode.h	/^	int (*vop_fsync)(struct vnode *object);$/;"	m	struct:vnode_ops
vop_getdirentry	include/vnode.h	/^	int (*vop_getdirentry)(struct vnode *dir, struct uio *uio);$/;"	m	struct:vnode_ops
vop_gettype	include/vnode.h	/^	int (*vop_gettype)(struct vnode *object, u_int32_t *result);$/;"	m	struct:vnode_ops
vop_ioctl	include/vnode.h	/^	int (*vop_ioctl)(struct vnode *object, int op, userptr_t data);$/;"	m	struct:vnode_ops
vop_link	include/vnode.h	/^	int (*vop_link)(struct vnode *dir, $/;"	m	struct:vnode_ops
vop_lookparent	include/vnode.h	/^	int (*vop_lookparent)(struct vnode *dir,$/;"	m	struct:vnode_ops
vop_lookup	include/vnode.h	/^	int (*vop_lookup)(struct vnode *dir, $/;"	m	struct:vnode_ops
vop_magic	include/vnode.h	/^	unsigned long vop_magic;	\/* should always be VOP_MAGIC *\/$/;"	m	struct:vnode_ops
vop_mkdir	include/vnode.h	/^	int (*vop_mkdir)(struct vnode *parentdir, $/;"	m	struct:vnode_ops
vop_mmap	include/vnode.h	/^	int (*vop_mmap)(struct vnode *file \/* add stuff *\/);$/;"	m	struct:vnode_ops
vop_namefile	include/vnode.h	/^	int (*vop_namefile)(struct vnode *file, struct uio *uio);$/;"	m	struct:vnode_ops
vop_open	include/vnode.h	/^	int (*vop_open)(struct vnode *object, int flags_from_open);$/;"	m	struct:vnode_ops
vop_read	include/vnode.h	/^	int (*vop_read)(struct vnode *file, struct uio *uio);$/;"	m	struct:vnode_ops
vop_readlink	include/vnode.h	/^	int (*vop_readlink)(struct vnode *link, struct uio *uio);$/;"	m	struct:vnode_ops
vop_reclaim	include/vnode.h	/^	int (*vop_reclaim)(struct vnode *vnode);$/;"	m	struct:vnode_ops
vop_remove	include/vnode.h	/^	int (*vop_remove)(struct vnode *dir, $/;"	m	struct:vnode_ops
vop_rename	include/vnode.h	/^	int (*vop_rename)(struct vnode *vn1, const char *name1, $/;"	m	struct:vnode_ops
vop_rmdir	include/vnode.h	/^	int (*vop_rmdir)(struct vnode *dir,$/;"	m	struct:vnode_ops
vop_stat	include/vnode.h	/^	int (*vop_stat)(struct vnode *object, struct stat *statbuf);$/;"	m	struct:vnode_ops
vop_symlink	include/vnode.h	/^	int (*vop_symlink)(struct vnode *dir, $/;"	m	struct:vnode_ops
vop_truncate	include/vnode.h	/^	int (*vop_truncate)(struct vnode *file, off_t len);$/;"	m	struct:vnode_ops
vop_tryseek	include/vnode.h	/^	int (*vop_tryseek)(struct vnode *object, off_t pos);$/;"	m	struct:vnode_ops
vop_write	include/vnode.h	/^	int (*vop_write)(struct vnode *file, struct uio *uio);$/;"	m	struct:vnode_ops
waitaddrs	test/tt3.c	/^static const char waitaddrs[NWAITADDRS];  \/* N distinct wait addresses *\/$/;"	v	file:
waker_thread	test/tt3.c	/^waker_thread(void *junk1, unsigned long junk2)$/;"	f	file:
wakerdone	test/tt3.c	/^static volatile int wakerdone;$/;"	v	file:
wakersem	test/tt3.c	/^static struct semaphore *wakersem;$/;"	v	typeref:struct:semaphore	file:
write_cfg_register	dev/lamebus/lamebus.c	/^write_cfg_register(struct lamebus_softc *lb, int slot, u_int32_t offset,$/;"	f	file:
write_ctl_register	dev/lamebus/lamebus.c	/^write_ctl_register(struct lamebus_softc *lb, u_int32_t offset, u_int32_t val)$/;"	f	file:
write_out_block	cache/cache.c	/^write_out_block(int id, void *data)$/;"	f	file:
writestress	test/fstest.c	/^DEFTEST(writestress);$/;"	v
writestress2	test/fstest.c	/^DEFTEST(writestress2);$/;"	v
writestress2_thread	test/fstest.c	/^writestress2_thread(void *fs, unsigned long num)$/;"	f	file:
writestress_thread	test/fstest.c	/^writestress_thread(void *fs, unsigned long num)$/;"	f	file:
z0	arch/mips/include/asmdefs.h	10;"	d
zombies	thread/thread.c	/^static struct array *zombies;$/;"	v	typeref:struct:array	file:
